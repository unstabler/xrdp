diff --git a/xorgxrdp_helper/nvEncodeAPI.h b/xorgxrdp_helper/nvEncodeAPI.h
index 257e3de..9997988 100644
--- a/xorgxrdp_helper/nvEncodeAPI.h
+++ b/xorgxrdp_helper/nvEncodeAPI.h
@@ -105,10 +105,10 @@ typedef struct _NVENC_RECT
 
 /** @} */ /* End of GUID and NVENC_RECT structure grouping*/
 
-typedef void* NV_ENC_INPUT_PTR;             /**< NVENCODE API input buffer                              */
-typedef void* NV_ENC_OUTPUT_PTR;            /**< NVENCODE API output buffer*/
-typedef void* NV_ENC_REGISTERED_PTR;        /**< A Resource that has been registered with NVENCODE API*/
-typedef void* NV_ENC_CUSTREAM_PTR;          /**< Pointer to CUstream*/
+typedef void *NV_ENC_INPUT_PTR;             /**< NVENCODE API input buffer                              */
+typedef void *NV_ENC_OUTPUT_PTR;            /**< NVENCODE API output buffer*/
+typedef void *NV_ENC_REGISTERED_PTR;        /**< A Resource that has been registered with NVENCODE API*/
+typedef void *NV_ENC_CUSTREAM_PTR;          /**< Pointer to CUstream*/
 
 #define NVENCAPI_MAJOR_VERSION 11
 #define NVENCAPI_MINOR_VERSION 1
@@ -140,7 +140,7 @@ static const GUID NV_ENC_CODEC_H264_GUID =
 { 0x6bc82762, 0x4e63, 0x4ca4, { 0xaa, 0x85, 0x1e, 0x50, 0xf3, 0x21, 0xf6, 0xbf } };
 
 // {790CDC88-4522-4d7b-9425-BDA9975F7603}
-static const GUID NV_ENC_CODEC_HEVC_GUID = 
+static const GUID NV_ENC_CODEC_HEVC_GUID =
 { 0x790cdc88, 0x4522, 0x4d7b, { 0x94, 0x25, 0xbd, 0xa9, 0x97, 0x5f, 0x76, 0x3 } };
 
 
@@ -150,7 +150,7 @@ static const GUID NV_ENC_CODEC_HEVC_GUID =
 // =========================================================================================
 
 // {BFD6F8E7-233C-4341-8B3E-4818523803F4}
-static const GUID NV_ENC_CODEC_PROFILE_AUTOSELECT_GUID = 
+static const GUID NV_ENC_CODEC_PROFILE_AUTOSELECT_GUID =
 { 0xbfd6f8e7, 0x233c, 0x4341, { 0x8b, 0x3e, 0x48, 0x18, 0x52, 0x38, 0x3, 0xf4 } };
 
 // {0727BCAA-78C4-4c83-8C2F-EF3DFF267C6A}
@@ -166,7 +166,7 @@ static const GUID NV_ENC_H264_PROFILE_HIGH_GUID =
 { 0xe7cbc309, 0x4f7a, 0x4b89, { 0xaf, 0x2a, 0xd5, 0x37, 0xc9, 0x2b, 0xe3, 0x10 } };
 
 // {7AC663CB-A598-4960-B844-339B261A7D52}
-static const GUID  NV_ENC_H264_PROFILE_HIGH_444_GUID = 
+static const GUID  NV_ENC_H264_PROFILE_HIGH_444_GUID =
 { 0x7ac663cb, 0xa598, 0x4960, { 0xb8, 0x44, 0x33, 0x9b, 0x26, 0x1a, 0x7d, 0x52 } };
 
 // {40847BF5-33F7-4601-9084-E8FE3C1DB8B7}
@@ -174,24 +174,24 @@ static const GUID NV_ENC_H264_PROFILE_STEREO_GUID =
 { 0x40847bf5, 0x33f7, 0x4601, { 0x90, 0x84, 0xe8, 0xfe, 0x3c, 0x1d, 0xb8, 0xb7 } };
 
 // {B405AFAC-F32B-417B-89C4-9ABEED3E5978}
-static const GUID NV_ENC_H264_PROFILE_PROGRESSIVE_HIGH_GUID = 
+static const GUID NV_ENC_H264_PROFILE_PROGRESSIVE_HIGH_GUID =
 { 0xb405afac, 0xf32b, 0x417b, { 0x89, 0xc4, 0x9a, 0xbe, 0xed, 0x3e, 0x59, 0x78 } };
 
 // {AEC1BD87-E85B-48f2-84C3-98BCA6285072}
-static const GUID NV_ENC_H264_PROFILE_CONSTRAINED_HIGH_GUID = 
+static const GUID NV_ENC_H264_PROFILE_CONSTRAINED_HIGH_GUID =
 { 0xaec1bd87, 0xe85b, 0x48f2, { 0x84, 0xc3, 0x98, 0xbc, 0xa6, 0x28, 0x50, 0x72 } };
 
 // {B514C39A-B55B-40fa-878F-F1253B4DFDEC}
-static const GUID NV_ENC_HEVC_PROFILE_MAIN_GUID = 
+static const GUID NV_ENC_HEVC_PROFILE_MAIN_GUID =
 { 0xb514c39a, 0xb55b, 0x40fa, { 0x87, 0x8f, 0xf1, 0x25, 0x3b, 0x4d, 0xfd, 0xec } };
 
 // {fa4d2b6c-3a5b-411a-8018-0a3f5e3c9be5}
-static const GUID NV_ENC_HEVC_PROFILE_MAIN10_GUID = 
+static const GUID NV_ENC_HEVC_PROFILE_MAIN10_GUID =
 { 0xfa4d2b6c, 0x3a5b, 0x411a, { 0x80, 0x18, 0x0a, 0x3f, 0x5e, 0x3c, 0x9b, 0xe5 } };
 
 // For HEVC Main 444 8 bit and HEVC Main 444 10 bit profiles only
 // {51ec32b5-1b4c-453c-9cbd-b616bd621341}
-static const GUID NV_ENC_HEVC_PROFILE_FREXT_GUID = 
+static const GUID NV_ENC_HEVC_PROFILE_FREXT_GUID =
 { 0x51ec32b5, 0x1b4c, 0x453c, { 0x9c, 0xbd, 0xb6, 0x16, 0xbd, 0x62, 0x13, 0x41 } };
 
 // =========================================================================================
@@ -210,15 +210,15 @@ NV_ENC_DEPRECATED static const GUID NV_ENC_PRESET_HQ_GUID =
 { 0x34dba71d, 0xa77b, 0x4b8f, { 0x9c, 0x3e, 0xb6, 0xd5, 0xda, 0x24, 0xc0, 0x12 } };
 
 // {82E3E450-BDBB-4e40-989C-82A90DF9EF32}
-NV_ENC_DEPRECATED static const GUID NV_ENC_PRESET_BD_GUID  = 
+NV_ENC_DEPRECATED static const GUID NV_ENC_PRESET_BD_GUID  =
 { 0x82e3e450, 0xbdbb, 0x4e40, { 0x98, 0x9c, 0x82, 0xa9, 0xd, 0xf9, 0xef, 0x32 } };
 
 // {49DF21C5-6DFA-4feb-9787-6ACC9EFFB726}
-NV_ENC_DEPRECATED static const GUID NV_ENC_PRESET_LOW_LATENCY_DEFAULT_GUID  = 
+NV_ENC_DEPRECATED static const GUID NV_ENC_PRESET_LOW_LATENCY_DEFAULT_GUID  =
 { 0x49df21c5, 0x6dfa, 0x4feb, { 0x97, 0x87, 0x6a, 0xcc, 0x9e, 0xff, 0xb7, 0x26 } };
 
 // {C5F733B9-EA97-4cf9-BEC2-BF78A74FD105}
-NV_ENC_DEPRECATED static const GUID NV_ENC_PRESET_LOW_LATENCY_HQ_GUID  = 
+NV_ENC_DEPRECATED static const GUID NV_ENC_PRESET_LOW_LATENCY_HQ_GUID  =
 { 0xc5f733b9, 0xea97, 0x4cf9, { 0xbe, 0xc2, 0xbf, 0x78, 0xa7, 0x4f, 0xd1, 0x5 } };
 
 // {67082A44-4BAD-48FA-98EA-93056D150A58}
@@ -226,42 +226,42 @@ NV_ENC_DEPRECATED static const GUID NV_ENC_PRESET_LOW_LATENCY_HP_GUID =
 { 0x67082a44, 0x4bad, 0x48fa, { 0x98, 0xea, 0x93, 0x5, 0x6d, 0x15, 0xa, 0x58 } };
 
 // {D5BFB716-C604-44e7-9BB8-DEA5510FC3AC}
-NV_ENC_DEPRECATED static const GUID NV_ENC_PRESET_LOSSLESS_DEFAULT_GUID = 
+NV_ENC_DEPRECATED static const GUID NV_ENC_PRESET_LOSSLESS_DEFAULT_GUID =
 { 0xd5bfb716, 0xc604, 0x44e7, { 0x9b, 0xb8, 0xde, 0xa5, 0x51, 0xf, 0xc3, 0xac } };
 
 // {149998E7-2364-411d-82EF-179888093409}
-NV_ENC_DEPRECATED static const GUID NV_ENC_PRESET_LOSSLESS_HP_GUID = 
+NV_ENC_DEPRECATED static const GUID NV_ENC_PRESET_LOSSLESS_HP_GUID =
 { 0x149998e7, 0x2364, 0x411d, { 0x82, 0xef, 0x17, 0x98, 0x88, 0x9, 0x34, 0x9 } };
 
-// Performance degrades and quality improves as we move from P1 to P7. Presets P3 to P7 for H264 and Presets P2 to P7 for HEVC have B frames enabled by default 
+// Performance degrades and quality improves as we move from P1 to P7. Presets P3 to P7 for H264 and Presets P2 to P7 for HEVC have B frames enabled by default
 // for HIGH_QUALITY and LOSSLESS tuning info, and will not work with Weighted Prediction enabled. In case Weighted Prediction is required, disable B frames by
 // setting frameIntervalP = 1
 // {FC0A8D3E-45F8-4CF8-80C7-298871590EBF}
-static const GUID NV_ENC_PRESET_P1_GUID   = 
+static const GUID NV_ENC_PRESET_P1_GUID   =
 { 0xfc0a8d3e, 0x45f8, 0x4cf8, { 0x80, 0xc7, 0x29, 0x88, 0x71, 0x59, 0xe, 0xbf } };
 
 // {F581CFB8-88D6-4381-93F0-DF13F9C27DAB}
-static const GUID NV_ENC_PRESET_P2_GUID   = 
+static const GUID NV_ENC_PRESET_P2_GUID   =
 { 0xf581cfb8, 0x88d6, 0x4381, { 0x93, 0xf0, 0xdf, 0x13, 0xf9, 0xc2, 0x7d, 0xab } };
 
 // {36850110-3A07-441F-94D5-3670631F91F6}
-static const GUID NV_ENC_PRESET_P3_GUID   = 
+static const GUID NV_ENC_PRESET_P3_GUID   =
 { 0x36850110, 0x3a07, 0x441f, { 0x94, 0xd5, 0x36, 0x70, 0x63, 0x1f, 0x91, 0xf6 } };
 
 // {90A7B826-DF06-4862-B9D2-CD6D73A08681}
-static const GUID NV_ENC_PRESET_P4_GUID   = 
+static const GUID NV_ENC_PRESET_P4_GUID   =
 { 0x90a7b826, 0xdf06, 0x4862, { 0xb9, 0xd2, 0xcd, 0x6d, 0x73, 0xa0, 0x86, 0x81 } };
 
 // {21C6E6B4-297A-4CBA-998F-B6CBDE72ADE3}
-static const GUID NV_ENC_PRESET_P5_GUID   = 
+static const GUID NV_ENC_PRESET_P5_GUID   =
 { 0x21c6e6b4, 0x297a, 0x4cba, { 0x99, 0x8f, 0xb6, 0xcb, 0xde, 0x72, 0xad, 0xe3 } };
 
 // {8E75C279-6299-4AB6-8302-0B215A335CF5}
-static const GUID NV_ENC_PRESET_P6_GUID   = 
+static const GUID NV_ENC_PRESET_P6_GUID   =
 { 0x8e75c279, 0x6299, 0x4ab6, { 0x83, 0x2, 0xb, 0x21, 0x5a, 0x33, 0x5c, 0xf5 } };
 
 // {84848C12-6F71-4C13-931B-53E283F57974}
-static const GUID NV_ENC_PRESET_P7_GUID   = 
+static const GUID NV_ENC_PRESET_P7_GUID   =
 { 0x84848c12, 0x6f71, 0x4c13, { 0x93, 0x1b, 0x53, 0xe2, 0x83, 0xf5, 0x79, 0x74 } };
 
 /**
@@ -355,7 +355,7 @@ typedef enum _NV_ENC_PIC_TYPE
     NV_ENC_PIC_TYPE_BI              = 0x04,    /**< Bi-directionally predicted with only Intra MBs */
     NV_ENC_PIC_TYPE_SKIPPED         = 0x05,    /**< Picture is skipped */
     NV_ENC_PIC_TYPE_INTRA_REFRESH   = 0x06,    /**< First picture in intra refresh cycle */
-    NV_ENC_PIC_TYPE_NONREF_P        = 0x07,    /**< Non reference P picture */            
+    NV_ENC_PIC_TYPE_NONREF_P        = 0x07,    /**< Non reference P picture */
     NV_ENC_PIC_TYPE_UNKNOWN         = 0xFF     /**< Picture type unknown */
 } NV_ENC_PIC_TYPE;
 
@@ -377,7 +377,7 @@ typedef enum _NV_ENC_MV_PRECISION
 typedef enum _NV_ENC_BUFFER_FORMAT
 {
     NV_ENC_BUFFER_FORMAT_UNDEFINED                       = 0x00000000,  /**< Undefined buffer format */
-                                                                       
+
     NV_ENC_BUFFER_FORMAT_NV12                            = 0x00000001,  /**< Semi-Planar YUV [Y plane followed by interleaved UV plane] */
     NV_ENC_BUFFER_FORMAT_YV12                            = 0x00000010,  /**< Planar YUV [Y plane followed by V and U planes] */
     NV_ENC_BUFFER_FORMAT_IYUV                            = 0x00000100,  /**< Planar YUV [Y plane followed by U and V planes] */
@@ -404,8 +404,8 @@ typedef enum _NV_ENC_BUFFER_FORMAT
                                                                              where a pixel is represented by a 32-bit word with R
                                                                              in the lowest 10 bits, G in the next 10 bits, B in the
                                                                              10 bits after that and A in the highest 2 bits. */
-    NV_ENC_BUFFER_FORMAT_U8                              = 0x40000000,  /**< Buffer format representing one-dimensional buffer. 
-                                                                             This format should be used only when registering the 
+    NV_ENC_BUFFER_FORMAT_U8                              = 0x40000000,  /**< Buffer format representing one-dimensional buffer.
+                                                                             This format should be used only when registering the
                                                                              resource as output buffer, which will be used to write
                                                                              the encoded bit stream or H.264 ME only mode output. */
 } NV_ENC_BUFFER_FORMAT;
@@ -421,7 +421,7 @@ typedef enum _NV_ENC_BUFFER_FORMAT
 typedef enum _NV_ENC_LEVEL
 {
     NV_ENC_LEVEL_AUTOSELECT         = 0,
-    
+
     NV_ENC_LEVEL_H264_1             = 10,
     NV_ENC_LEVEL_H264_1b            = 9,
     NV_ENC_LEVEL_H264_11            = 11,
@@ -482,7 +482,7 @@ typedef enum _NVENCSTATUS
     NV_ENC_ERR_UNSUPPORTED_DEVICE,
 
     /**
-     * This indicates that the encoder device supplied by the client is not 
+     * This indicates that the encoder device supplied by the client is not
      * valid.
      */
     NV_ENC_ERR_INVALID_ENCODERDEVICE,
@@ -493,9 +493,9 @@ typedef enum _NVENCSTATUS
     NV_ENC_ERR_INVALID_DEVICE,
 
     /**
-     * This indicates that device passed to the API call is no longer available and 
-     * needs to be reinitialized. The clients need to destroy the current encoder  
-     * session by freeing the allocated input output buffers and destroying the device 
+     * This indicates that device passed to the API call is no longer available and
+     * needs to be reinitialized. The clients need to destroy the current encoder
+     * session by freeing the allocated input output buffers and destroying the device
      * and create a new encoding session.
      */
     NV_ENC_ERR_DEVICE_NOT_EXIST,
@@ -524,11 +524,11 @@ typedef enum _NVENCSTATUS
     NV_ENC_ERR_INVALID_CALL,
 
     /**
-     * This indicates that the API call failed because it was unable to allocate 
+     * This indicates that the API call failed because it was unable to allocate
      * enough memory to perform the requested operation.
      */
     NV_ENC_ERR_OUT_OF_MEMORY,
-    
+
     /**
      * This indicates that the encoder has not been initialized with
      * ::NvEncInitializeEncoder() or that initialization has failed.
@@ -543,8 +543,8 @@ typedef enum _NVENCSTATUS
     NV_ENC_ERR_UNSUPPORTED_PARAM,
 
     /**
-     * This indicates that the ::NvEncLockBitstream() failed to lock the output 
-     * buffer. This happens when the client makes a non blocking lock call to 
+     * This indicates that the ::NvEncLockBitstream() failed to lock the output
+     * buffer. This happens when the client makes a non blocking lock call to
      * access the output bitstream by passing NV_ENC_LOCK_BITSTREAM::doNotWait flag.
      * This is not a fatal error and client should retry the same operation after
      * few milliseconds.
@@ -552,7 +552,7 @@ typedef enum _NVENCSTATUS
     NV_ENC_ERR_LOCK_BUSY,
 
     /**
-     * This indicates that the size of the user buffer passed by the client is 
+     * This indicates that the size of the user buffer passed by the client is
      * insufficient for the requested operation.
      */
     NV_ENC_ERR_NOT_ENOUGH_BUFFER,
@@ -572,10 +572,10 @@ typedef enum _NVENCSTATUS
      * This indicates encode driver requires more input buffers to produce an output
      * bitstream. If this error is returned from ::NvEncEncodePicture() API, this
      * is not a fatal error. If the client is encoding with B frames then,
-     * ::NvEncEncodePicture() API might be buffering the input frame for re-ordering. 
-     * 
+     * ::NvEncEncodePicture() API might be buffering the input frame for re-ordering.
+     *
      * A client operating in synchronous mode cannot call ::NvEncLockBitstream()
-     * API on the output bitstream buffer if ::NvEncEncodePicture() returned the 
+     * API on the output bitstream buffer if ::NvEncEncodePicture() returned the
      * ::NV_ENC_ERR_NEED_MORE_INPUT error code.
      * The client must continue providing input frames until encode driver returns
      * ::NV_ENC_SUCCESS. After receiving ::NV_ENC_SUCCESS status the client can call
@@ -585,7 +585,7 @@ typedef enum _NVENCSTATUS
     NV_ENC_ERR_NEED_MORE_INPUT,
 
     /**
-     * This indicates that the HW encoder is busy encoding and is unable to encode  
+     * This indicates that the HW encoder is busy encoding and is unable to encode
      * the input. The client should call ::NvEncEncodePicture() again after few
      * milliseconds.
      */
@@ -601,13 +601,13 @@ typedef enum _NVENCSTATUS
      * This indicates that an unknown internal error has occurred.
      */
     NV_ENC_ERR_GENERIC,
-    
+
     /**
      * This indicates that the client is attempting to use a feature
      * that is not available for the license type for the current system.
      */
     NV_ENC_ERR_INCOMPATIBLE_CLIENT_KEY,
-    
+
     /**
      * This indicates that the client is attempting to use a feature
      * that is not implemented for the current version.
@@ -639,11 +639,11 @@ typedef enum _NVENCSTATUS
 typedef enum _NV_ENC_PIC_FLAGS
 {
     NV_ENC_PIC_FLAG_FORCEINTRA         = 0x1,   /**< Encode the current picture as an Intra picture */
-    NV_ENC_PIC_FLAG_FORCEIDR           = 0x2,   /**< Encode the current picture as an IDR picture. 
+    NV_ENC_PIC_FLAG_FORCEIDR           = 0x2,   /**< Encode the current picture as an IDR picture.
                                                      This flag is only valid when Picture type decision is taken by the Encoder
                                                      [_NV_ENC_INITIALIZE_PARAMS::enablePTD == 1]. */
     NV_ENC_PIC_FLAG_OUTPUT_SPSPPS      = 0x4,   /**< Write the sequence and picture header in encoded bitstream of the current picture */
-    NV_ENC_PIC_FLAG_EOS                = 0x8,   /**< Indicates end of the input stream */ 
+    NV_ENC_PIC_FLAG_EOS                = 0x8,   /**< Indicates end of the input stream */
 } NV_ENC_PIC_FLAGS;
 
 /**
@@ -741,7 +741,7 @@ typedef enum _NV_ENC_INPUT_RESOURCE_TYPE
 typedef enum _NV_ENC_BUFFER_USAGE
 {
     NV_ENC_INPUT_IMAGE              = 0x0,          /**< Registered surface will be used for input image */
-    NV_ENC_OUTPUT_MOTION_VECTOR     = 0x1,          /**< Registered surface will be used for output of H.264 ME only mode. 
+    NV_ENC_OUTPUT_MOTION_VECTOR     = 0x1,          /**< Registered surface will be used for output of H.264 ME only mode.
                                                          This buffer usage type is not supported for HEVC ME only mode. */
     NV_ENC_OUTPUT_BITSTREAM         = 0x2           /**< Registered surface will be used for output bitstream in encoding */
 } NV_ENC_BUFFER_USAGE;
@@ -788,13 +788,13 @@ typedef enum _NV_ENC_CAPS
      */
     NV_ENC_CAPS_SUPPORTED_RATECONTROL_MODES,
 
-    /** 
+    /**
      * Indicates HW support for field mode encoding.
      * \n 0 : Interlaced mode encoding is not supported.
      * \n 1 : Interlaced field mode encoding is supported.
      * \n 2 : Interlaced frame encoding and field mode encoding are both supported.
      */
-     NV_ENC_CAPS_SUPPORT_FIELD_ENCODING,
+    NV_ENC_CAPS_SUPPORT_FIELD_ENCODING,
 
     /**
      * Indicates HW support for monochrome mode encoding.
@@ -870,7 +870,7 @@ typedef enum _NV_ENC_CAPS
      * Maximum Encoding level supported (See ::NV_ENC_LEVEL for details).
      */
     NV_ENC_CAPS_LEVEL_MAX,
- 
+
     /**
      * Minimum Encoding level supported (See ::NV_ENC_LEVEL for details).
      */
@@ -882,12 +882,12 @@ typedef enum _NV_ENC_CAPS
      * \n 1 : Separate colour plane encoding supported.
      */
     NV_ENC_CAPS_SEPARATE_COLOUR_PLANE,
-    
+
     /**
      * Maximum output width supported.
      */
     NV_ENC_CAPS_WIDTH_MAX,
-    
+
     /**
      * Maximum output height supported.
      */
@@ -915,7 +915,7 @@ typedef enum _NV_ENC_CAPS
      * \n 1 : Dynamic Encode bitrate change supported.
      */
     NV_ENC_CAPS_SUPPORT_DYN_BITRATE_CHANGE,
-        
+
     /**
      * Indicates Forcing Constant QP On The Fly Support.
      * Support added from NvEncodeAPI version 2.0.
@@ -925,7 +925,7 @@ typedef enum _NV_ENC_CAPS
     NV_ENC_CAPS_SUPPORT_DYN_FORCE_CONSTQP,
 
     /**
-     * Indicates Dynamic rate control mode Change Support.    
+     * Indicates Dynamic rate control mode Change Support.
      * \n 0 : Dynamic rate control mode change not supported.
      * \n 1 : Dynamic rate control mode change supported.
      */
@@ -981,7 +981,7 @@ typedef enum _NV_ENC_CAPS
      * \n 1 : Reference Picture Invalidation supported.
      */
     NV_ENC_CAPS_SUPPORT_REF_PIC_INVALIDATION,
-    
+
     /**
      * Indicates support for Pre-Processing.
      * The API return value is a bitmask of the values defined in ::NV_ENC_PREPROC_FLAGS
@@ -1018,12 +1018,12 @@ typedef enum _NV_ENC_CAPS
      * \n 1 : lossless encoding supported.
      */
     NV_ENC_CAPS_SUPPORT_LOSSLESS_ENCODE,
-    
-     /**
-     * Indicates HW support for Sample Adaptive Offset.
-     * \n 0 : SAO not supported.
-     * \n 1 : SAO encoding supported.
-     */
+
+    /**
+    * Indicates HW support for Sample Adaptive Offset.
+    * \n 0 : SAO not supported.
+    * \n 1 : SAO encoding supported.
+    */
     NV_ENC_CAPS_SUPPORT_SAO,
 
     /**
@@ -1067,22 +1067,22 @@ typedef enum _NV_ENC_CAPS
 
 
     /**
-     * On managed (vGPU) platforms (Windows only), this API, in conjunction with other GRID Management APIs, can be used 
-     * to estimate the residual capacity of the hardware encoder on the GPU as a percentage of the total available encoder capacity. 
-     * This API can be called at any time; i.e. during the encode session or before opening the encode session. 
-     * If the available encoder capacity is returned as zero, applications may choose to switch to software encoding 
+     * On managed (vGPU) platforms (Windows only), this API, in conjunction with other GRID Management APIs, can be used
+     * to estimate the residual capacity of the hardware encoder on the GPU as a percentage of the total available encoder capacity.
+     * This API can be called at any time; i.e. during the encode session or before opening the encode session.
+     * If the available encoder capacity is returned as zero, applications may choose to switch to software encoding
      * and continue to call this API (e.g. polling once per second) until capacity becomes available.
      *
      * On bare metal (non-virtualized GPU) and linux platforms, this API always returns 100.
      */
     NV_ENC_CAPS_DYNAMIC_QUERY_ENCODER_CAPACITY,
 
-     /**
-     * Indicates B as reference support.
-     * \n 0 : B as reference is not supported.
-     * \n 1 : each B-Frame as reference is supported.
-     * \n 2 : only Middle B-frame as reference is supported.
-     */
+    /**
+    * Indicates B as reference support.
+    * \n 0 : B as reference is not supported.
+    * \n 1 : each B-Frame as reference is supported.
+    * \n 2 : only Middle B-frame as reference is supported.
+    */
     NV_ENC_CAPS_SUPPORT_BFRAME_REF_MODE,
 
     /**
@@ -1114,9 +1114,9 @@ typedef enum _NV_ENC_CAPS
      */
     NV_ENC_CAPS_SUPPORT_ALPHA_LAYER_ENCODING,
 
-     /**
-     * Indicates number of Encoding engines present on GPU.
-     */
+    /**
+    * Indicates number of Encoding engines present on GPU.
+    */
     NV_ENC_CAPS_NUM_ENCODER_ENGINES,
 
     /**
@@ -1124,9 +1124,9 @@ typedef enum _NV_ENC_CAPS
      */
     NV_ENC_CAPS_SINGLE_SLICE_INTRA_REFRESH,
 
-     /**
-     * Reserved - Not to be used by clients.
-     */
+    /**
+    * Reserved - Not to be used by clients.
+    */
     NV_ENC_CAPS_EXPOSED_COUNT
 } NV_ENC_CAPS;
 
@@ -1140,7 +1140,7 @@ typedef enum _NV_ENC_HEVC_CUSIZE
     NV_ENC_HEVC_CUSIZE_16x16      = 2,
     NV_ENC_HEVC_CUSIZE_32x32      = 3,
     NV_ENC_HEVC_CUSIZE_64x64      = 4,
-}NV_ENC_HEVC_CUSIZE;
+} NV_ENC_HEVC_CUSIZE;
 
 /**
  * Input struct for querying Encoding capabilities.
@@ -1167,7 +1167,7 @@ typedef struct _NV_ENC_ENCODE_OUT_PARAMS
 } NV_ENC_ENCODE_OUT_PARAMS;
 
 /** NV_ENC_ENCODE_OUT_PARAMS struct version. */
-#define NV_ENC_ENCODE_OUT_PARAMS_VER NVENCAPI_STRUCT_VERSION(1) 
+#define NV_ENC_ENCODE_OUT_PARAMS_VER NVENCAPI_STRUCT_VERSION(1)
 
 /**
  * Creation parameters for input buffer.
@@ -1181,13 +1181,13 @@ typedef struct _NV_ENC_CREATE_INPUT_BUFFER
     NV_ENC_BUFFER_FORMAT      bufferFmt;               /**< [in]: Input buffer format */
     uint32_t                  reserved;                /**< [in]: Reserved and must be set to 0 */
     NV_ENC_INPUT_PTR          inputBuffer;             /**< [out]: Pointer to input buffer */
-    void*                     pSysMemBuffer;           /**< [in]: Pointer to existing system memory buffer */
+    void                     *pSysMemBuffer;           /**< [in]: Pointer to existing system memory buffer */
     uint32_t                  reserved1[57];           /**< [in]: Reserved and must be set to 0 */
-    void*                     reserved2[63];           /**< [in]: Reserved and must be set to NULL */
+    void                     *reserved2[63];           /**< [in]: Reserved and must be set to NULL */
 } NV_ENC_CREATE_INPUT_BUFFER;
 
 /** NV_ENC_CREATE_INPUT_BUFFER struct version. */
-#define NV_ENC_CREATE_INPUT_BUFFER_VER NVENCAPI_STRUCT_VERSION(1) 
+#define NV_ENC_CREATE_INPUT_BUFFER_VER NVENCAPI_STRUCT_VERSION(1)
 
 /**
  * Creation parameters for output bitstream buffer.
@@ -1199,16 +1199,16 @@ typedef struct _NV_ENC_CREATE_BITSTREAM_BUFFER
     NV_ENC_MEMORY_HEAP    memoryHeap;                  /**< [in]: Deprecated. Do not use */
     uint32_t              reserved;                    /**< [in]: Reserved and must be set to 0 */
     NV_ENC_OUTPUT_PTR     bitstreamBuffer;             /**< [out]: Pointer to the output bitstream buffer */
-    void*                 bitstreamBufferPtr;          /**< [out]: Reserved and should not be used */
+    void                 *bitstreamBufferPtr;          /**< [out]: Reserved and should not be used */
     uint32_t              reserved1[58];               /**< [in]: Reserved and should be set to 0 */
-    void*                 reserved2[64];               /**< [in]: Reserved and should be set to NULL */
+    void                 *reserved2[64];               /**< [in]: Reserved and should be set to NULL */
 } NV_ENC_CREATE_BITSTREAM_BUFFER;
 
 /** NV_ENC_CREATE_BITSTREAM_BUFFER struct version. */
 #define NV_ENC_CREATE_BITSTREAM_BUFFER_VER NVENCAPI_STRUCT_VERSION(1)
 
 /**
- * Structs needed for ME only mode. 
+ * Structs needed for ME only mode.
  */
 typedef struct _NV_ENC_MVECTOR
 {
@@ -1216,7 +1216,7 @@ typedef struct _NV_ENC_MVECTOR
     int16_t             mvy;               /**< the y component of MV in quarter-pel units */
 } NV_ENC_MVECTOR;
 
-/** 
+/**
  * Motion vector structure per macroblock for H264 motion estimation.
  */
 typedef struct _NV_ENC_H264_MV_DATA
@@ -1250,13 +1250,13 @@ typedef struct _NV_ENC_CREATE_MV_BUFFER
     uint32_t            version;           /**< [in]: Struct version. Must be set to NV_ENC_CREATE_MV_BUFFER_VER */
     NV_ENC_OUTPUT_PTR   mvBuffer;          /**< [out]: Pointer to the output motion vector buffer */
     uint32_t            reserved1[255];    /**< [in]: Reserved and should be set to 0 */
-    void*               reserved2[63];     /**< [in]: Reserved and should be set to NULL */
+    void               *reserved2[63];     /**< [in]: Reserved and should be set to NULL */
 } NV_ENC_CREATE_MV_BUFFER;
 
 /** NV_ENC_CREATE_MV_BUFFER struct version*/
 #define NV_ENC_CREATE_MV_BUFFER_VER NVENCAPI_STRUCT_VERSION(1)
 
-/** 
+/**
  * QP value for frames
  */
 typedef struct _NV_ENC_QP
@@ -1269,8 +1269,8 @@ typedef struct _NV_ENC_QP
 /**
  * Rate Control Configuration Parameters
  */
- typedef struct _NV_ENC_RC_PARAMS
- {
+typedef struct _NV_ENC_RC_PARAMS
+{
     uint32_t                        version;
     NV_ENC_PARAMS_RC_MODE           rateControlMode;                             /**< [in]: Specifies the rate control mode. Check support for various rate control modes using ::NV_ENC_CAPS_SUPPORTED_RATECONTROL_MODES caps. */
     NV_ENC_QP                       constQP;                                     /**< [in]: Specifies the initial QP to be used for encoding, these values would be used for all frames if in Constant QP mode. */
@@ -1278,21 +1278,21 @@ typedef struct _NV_ENC_QP
     uint32_t                        maxBitRate;                                  /**< [in]: Specifies the maximum bitrate for the encoded output. This is used for VBR and ignored for CBR mode. */
     uint32_t                        vbvBufferSize;                               /**< [in]: Specifies the VBV(HRD) buffer size. in bits. Set 0 to use the default VBV  buffer size. */
     uint32_t                        vbvInitialDelay;                             /**< [in]: Specifies the VBV(HRD) initial delay in bits. Set 0 to use the default VBV  initial delay .*/
-    uint32_t                        enableMinQP          :1;                     /**< [in]: Set this to 1 if minimum QP used for rate control. */
-    uint32_t                        enableMaxQP          :1;                     /**< [in]: Set this to 1 if maximum QP used for rate control. */
-    uint32_t                        enableInitialRCQP    :1;                     /**< [in]: Set this to 1 if user supplied initial QP is used for rate control. */
-    uint32_t                        enableAQ             :1;                     /**< [in]: Set this to 1 to enable adaptive quantization (Spatial). */
-    uint32_t                        reservedBitField1    :1;                     /**< [in]: Reserved bitfields and must be set to 0. */
-    uint32_t                        enableLookahead      :1;                     /**< [in]: Set this to 1 to enable lookahead with depth <lookaheadDepth> (if lookahead is enabled, input frames must remain available to the encoder until encode completion) */
-    uint32_t                        disableIadapt        :1;                     /**< [in]: Set this to 1 to disable adaptive I-frame insertion at scene cuts (only has an effect when lookahead is enabled) */
-    uint32_t                        disableBadapt        :1;                     /**< [in]: Set this to 1 to disable adaptive B-frame decision (only has an effect when lookahead is enabled) */
-    uint32_t                        enableTemporalAQ     :1;                     /**< [in]: Set this to 1 to enable temporal AQ */
-    uint32_t                        zeroReorderDelay     :1;                     /**< [in]: Set this to 1 to indicate zero latency operation (no reordering delay, num_reorder_frames=0) */
-    uint32_t                        enableNonRefP        :1;                     /**< [in]: Set this to 1 to enable automatic insertion of non-reference P-frames (no effect if enablePTD=0) */
-    uint32_t                        strictGOPTarget      :1;                     /**< [in]: Set this to 1 to minimize GOP-to-GOP rate fluctuations */
-    uint32_t                        aqStrength           :4;                     /**< [in]: When AQ (Spatial) is enabled (i.e. NV_ENC_RC_PARAMS::enableAQ is set), this field is used to specify AQ strength. AQ strength scale is from 1 (low) - 15 (aggressive). 
+    uint32_t                        enableMinQP          : 1;                    /**< [in]: Set this to 1 if minimum QP used for rate control. */
+    uint32_t                        enableMaxQP          : 1;                    /**< [in]: Set this to 1 if maximum QP used for rate control. */
+    uint32_t                        enableInitialRCQP    : 1;                    /**< [in]: Set this to 1 if user supplied initial QP is used for rate control. */
+    uint32_t                        enableAQ             : 1;                    /**< [in]: Set this to 1 to enable adaptive quantization (Spatial). */
+    uint32_t                        reservedBitField1    : 1;                    /**< [in]: Reserved bitfields and must be set to 0. */
+    uint32_t                        enableLookahead      : 1;                    /**< [in]: Set this to 1 to enable lookahead with depth <lookaheadDepth> (if lookahead is enabled, input frames must remain available to the encoder until encode completion) */
+    uint32_t                        disableIadapt        : 1;                    /**< [in]: Set this to 1 to disable adaptive I-frame insertion at scene cuts (only has an effect when lookahead is enabled) */
+    uint32_t                        disableBadapt        : 1;                    /**< [in]: Set this to 1 to disable adaptive B-frame decision (only has an effect when lookahead is enabled) */
+    uint32_t                        enableTemporalAQ     : 1;                    /**< [in]: Set this to 1 to enable temporal AQ */
+    uint32_t                        zeroReorderDelay     : 1;                    /**< [in]: Set this to 1 to indicate zero latency operation (no reordering delay, num_reorder_frames=0) */
+    uint32_t                        enableNonRefP        : 1;                    /**< [in]: Set this to 1 to enable automatic insertion of non-reference P-frames (no effect if enablePTD=0) */
+    uint32_t                        strictGOPTarget      : 1;                    /**< [in]: Set this to 1 to minimize GOP-to-GOP rate fluctuations */
+    uint32_t                        aqStrength           : 4;                     /**< [in]: When AQ (Spatial) is enabled (i.e. NV_ENC_RC_PARAMS::enableAQ is set), this field is used to specify AQ strength. AQ strength scale is from 1 (low) - 15 (aggressive).
                                                                                             If not set, strength is auto selected by driver. */
-    uint32_t                        reservedBitFields    :16;                    /**< [in]: Reserved bitfields and must be set to 0 */
+    uint32_t                        reservedBitFields    : 16;                   /**< [in]: Reserved bitfields and must be set to 0 */
     NV_ENC_QP                       minQP;                                       /**< [in]: Specifies the minimum QP used for rate control. Client must set NV_ENC_CONFIG::enableMinQP to 1. */
     NV_ENC_QP                       maxQP;                                       /**< [in]: Specifies the maximum QP used for rate control. Client must set NV_ENC_CONFIG::enableMaxQP to 1. */
     NV_ENC_QP                       initialRCQP;                                 /**< [in]: Specifies the initial QP used for rate control. Client must set NV_ENC_CONFIG::enableInitialRCQP to 1. */
@@ -1302,15 +1302,15 @@ typedef struct _NV_ENC_QP
                                                                                             Applicable only for constant QP mode (NV_ENC_RC_PARAMS::rateControlMode = NV_ENC_PARAMS_RC_CONSTQP). */
     uint8_t                         targetQuality;                               /**< [in]: Target CQ (Constant Quality) level for VBR mode (range 0-51 with 0-automatic)  */
     uint8_t                         targetQualityLSB;                            /**< [in]: Fractional part of target quality (as 8.8 fixed point format) */
-    uint16_t                        lookaheadDepth;                              /**< [in]: Maximum depth of lookahead with range 0-(31 - number of B frames). 
+    uint16_t                        lookaheadDepth;                              /**< [in]: Maximum depth of lookahead with range 0-(31 - number of B frames).
                                                                                             lookaheadDepth is only used if enableLookahead=1.*/
     uint8_t                         lowDelayKeyFrameScale;                       /**< [in]: Specifies the ratio of I frame bits to P frame bits in case of single frame VBV and CBR rate control mode,
                                                                                             is set to 2 by default for low latency tuning info and 1 by default for ultra low latency tuning info  */
     uint8_t                         reserved1[3];
     NV_ENC_QP_MAP_MODE              qpMapMode;                                   /**< [in]: This flag is used to interpret values in array specified by NV_ENC_PIC_PARAMS::qpDeltaMap.
-                                                                                            Set this to NV_ENC_QP_MAP_EMPHASIS to treat values specified by NV_ENC_PIC_PARAMS::qpDeltaMap as Emphasis Level Map. 
-                                                                                            Emphasis Level can be assigned any value specified in enum NV_ENC_EMPHASIS_MAP_LEVEL. 
-                                                                                            Emphasis Level Map is used to specify regions to be encoded at varying levels of quality. 
+                                                                                            Set this to NV_ENC_QP_MAP_EMPHASIS to treat values specified by NV_ENC_PIC_PARAMS::qpDeltaMap as Emphasis Level Map.
+                                                                                            Emphasis Level can be assigned any value specified in enum NV_ENC_EMPHASIS_MAP_LEVEL.
+                                                                                            Emphasis Level Map is used to specify regions to be encoded at varying levels of quality.
                                                                                             The hardware encoder adjusts the quantization within the image as per the provided emphasis map,
                                                                                             by adjusting the quantization parameter (QP) assigned to each macroblock. This adjustment is commonly called “Delta QP”.
                                                                                             The adjustment depends on the absolute QP decided by the rate control algorithm, and is applied after the rate control has decided each macroblock’s QP.
@@ -1318,24 +1318,24 @@ typedef struct _NV_ENC_QP
                                                                                             Emphasis Level Map is useful in situations where client has a priori knowledge of the image complexity (e.g. via use of NVFBC's Classification feature) and encoding those high-complexity areas at higher quality (lower QP) is important, even at the possible cost of violating bitrate/VBV buffer size constraints
                                                                                             This feature is not supported when AQ( Spatial/Temporal) is enabled.
                                                                                             This feature is only supported for H264 codec currently.
-                                                                                            
-                                                                                            Set this to NV_ENC_QP_MAP_DELTA to treat values specified by NV_ENC_PIC_PARAMS::qpDeltaMap as QP Delta. This specifies QP modifier to be applied on top of the QP chosen by rate control 
-                                                                                            
+
+                                                                                            Set this to NV_ENC_QP_MAP_DELTA to treat values specified by NV_ENC_PIC_PARAMS::qpDeltaMap as QP Delta. This specifies QP modifier to be applied on top of the QP chosen by rate control
+
                                                                                             Set this to NV_ENC_QP_MAP_DISABLED to ignore NV_ENC_PIC_PARAMS::qpDeltaMap values. In this case, qpDeltaMap should be set to NULL.
-                                                                                             
+
                                                                                             Other values are reserved for future use.*/
     NV_ENC_MULTI_PASS               multiPass;                                    /**< [in]: This flag is used to enable multi-pass encoding for a given ::NV_ENC_PARAMS_RC_MODE. This flag is not valid for H264 and HEVC MEOnly mode */
-    uint32_t                        alphaLayerBitrateRatio;                       /**< [in]: Specifies the ratio in which bitrate should be split between base and alpha layer. A value 'x' for this field will split the target bitrate in a ratio of x : 1 between base and alpha layer. 
+    uint32_t                        alphaLayerBitrateRatio;                       /**< [in]: Specifies the ratio in which bitrate should be split between base and alpha layer. A value 'x' for this field will split the target bitrate in a ratio of x : 1 between base and alpha layer.
                                                                                              The default split ratio is 15.*/
     int8_t                          cbQPIndexOffset;                              /**< [in]: Specifies the value of 'chroma_qp_index_offset' in H264 / 'pps_cb_qp_offset' in HEVC.*/
     int8_t                          crQPIndexOffset;                              /**< [in]: Specifies the value of 'second_chroma_qp_index_offset' in H264 / 'pps_cr_qp_offset' in HEVC.*/
     uint16_t                        reserved2;
     uint32_t                        reserved[4];
- } NV_ENC_RC_PARAMS;
+} NV_ENC_RC_PARAMS;
 
 /** macro for constructing the version field of ::_NV_ENC_RC_PARAMS */
 #define NV_ENC_RC_PARAMS_VER NVENCAPI_STRUCT_VERSION(1)
- 
+
 
 
 /**
@@ -1358,7 +1358,7 @@ typedef struct _NV_ENC_CONFIG_H264_VUI_PARAMETERS
     uint32_t    chromaSampleLocationBot;              /**< [in]: Specifies the chroma sample location for bottom field(as defined in Annex E of the ITU-T Specification) */
     uint32_t    bitstreamRestrictionFlag;             /**< [in]: if set to 1, it specifies the bitstream restriction parameters are present in the bitstream.*/
     uint32_t    reserved[15];
-}NV_ENC_CONFIG_H264_VUI_PARAMETERS;
+} NV_ENC_CONFIG_H264_VUI_PARAMETERS;
 
 typedef NV_ENC_CONFIG_H264_VUI_PARAMETERS NV_ENC_CONFIG_HEVC_VUI_PARAMETERS;
 
@@ -1400,35 +1400,35 @@ typedef struct _NVENC_EXTERNAL_ME_HINT
  */
 typedef struct _NV_ENC_CONFIG_H264
 {
-    uint32_t enableTemporalSVC         :1;                          /**< [in]: Set to 1 to enable SVC temporal*/
-    uint32_t enableStereoMVC           :1;                          /**< [in]: Set to 1 to enable stereo MVC*/
-    uint32_t hierarchicalPFrames       :1;                          /**< [in]: Set to 1 to enable hierarchical P Frames */
-    uint32_t hierarchicalBFrames       :1;                          /**< [in]: Set to 1 to enable hierarchical B Frames */
-    uint32_t outputBufferingPeriodSEI  :1;                          /**< [in]: Set to 1 to write SEI buffering period syntax in the bitstream */
-    uint32_t outputPictureTimingSEI    :1;                          /**< [in]: Set to 1 to write SEI picture timing syntax in the bitstream.  When set for following rateControlMode : NV_ENC_PARAMS_RC_CBR, NV_ENC_PARAMS_RC_CBR_LOWDELAY_HQ,
-                                                                               NV_ENC_PARAMS_RC_CBR_HQ, filler data is inserted if needed to achieve HRD bitrate */ 
-    uint32_t outputAUD                 :1;                          /**< [in]: Set to 1 to write access unit delimiter syntax in bitstream */
-    uint32_t disableSPSPPS             :1;                          /**< [in]: Set to 1 to disable writing of Sequence and Picture parameter info in bitstream */
-    uint32_t outputFramePackingSEI     :1;                          /**< [in]: Set to 1 to enable writing of frame packing arrangement SEI messages to bitstream */
-    uint32_t outputRecoveryPointSEI    :1;                          /**< [in]: Set to 1 to enable writing of recovery point SEI message */
-    uint32_t enableIntraRefresh        :1;                          /**< [in]: Set to 1 to enable gradual decoder refresh or intra refresh. If the GOP structure uses B frames this will be ignored */
-    uint32_t enableConstrainedEncoding :1;                          /**< [in]: Set this to 1 to enable constrainedFrame encoding where each slice in the constrained picture is independent of other slices.
+    uint32_t enableTemporalSVC         : 1;                         /**< [in]: Set to 1 to enable SVC temporal*/
+    uint32_t enableStereoMVC           : 1;                         /**< [in]: Set to 1 to enable stereo MVC*/
+    uint32_t hierarchicalPFrames       : 1;                         /**< [in]: Set to 1 to enable hierarchical P Frames */
+    uint32_t hierarchicalBFrames       : 1;                         /**< [in]: Set to 1 to enable hierarchical B Frames */
+    uint32_t outputBufferingPeriodSEI  : 1;                         /**< [in]: Set to 1 to write SEI buffering period syntax in the bitstream */
+    uint32_t outputPictureTimingSEI    : 1;                          /**< [in]: Set to 1 to write SEI picture timing syntax in the bitstream.  When set for following rateControlMode : NV_ENC_PARAMS_RC_CBR, NV_ENC_PARAMS_RC_CBR_LOWDELAY_HQ,
+                                                                               NV_ENC_PARAMS_RC_CBR_HQ, filler data is inserted if needed to achieve HRD bitrate */
+    uint32_t outputAUD                 : 1;                         /**< [in]: Set to 1 to write access unit delimiter syntax in bitstream */
+    uint32_t disableSPSPPS             : 1;                         /**< [in]: Set to 1 to disable writing of Sequence and Picture parameter info in bitstream */
+    uint32_t outputFramePackingSEI     : 1;                         /**< [in]: Set to 1 to enable writing of frame packing arrangement SEI messages to bitstream */
+    uint32_t outputRecoveryPointSEI    : 1;                         /**< [in]: Set to 1 to enable writing of recovery point SEI message */
+    uint32_t enableIntraRefresh        : 1;                         /**< [in]: Set to 1 to enable gradual decoder refresh or intra refresh. If the GOP structure uses B frames this will be ignored */
+    uint32_t enableConstrainedEncoding : 1;                          /**< [in]: Set this to 1 to enable constrainedFrame encoding where each slice in the constrained picture is independent of other slices.
                                                                                Constrained encoding works only with rectangular slices.
                                                                                Check support for constrained encoding using ::NV_ENC_CAPS_SUPPORT_CONSTRAINED_ENCODING caps. */
-    uint32_t repeatSPSPPS              :1;                          /**< [in]: Set to 1 to enable writing of Sequence and Picture parameter for every IDR frame */
-    uint32_t enableVFR                 :1;                          /**< [in]: Setting enableVFR=1 currently only sets the fixed_frame_rate_flag=0 in the VUI but otherwise 
+    uint32_t repeatSPSPPS              : 1;                         /**< [in]: Set to 1 to enable writing of Sequence and Picture parameter for every IDR frame */
+    uint32_t enableVFR                 : 1;                          /**< [in]: Setting enableVFR=1 currently only sets the fixed_frame_rate_flag=0 in the VUI but otherwise
                                                                                has no impact on the encoder behavior. For more details please refer to E.1 VUI syntax of H.264 standard. Note, however, that NVENC does not support VFR encoding and rate control. */
-    uint32_t enableLTR                 :1;                          /**< [in]: Set to 1 to enable LTR (Long Term Reference) frame support. LTR can be used in two modes: "LTR Trust" mode and "LTR Per Picture" mode.
+    uint32_t enableLTR                 : 1;                          /**< [in]: Set to 1 to enable LTR (Long Term Reference) frame support. LTR can be used in two modes: "LTR Trust" mode and "LTR Per Picture" mode.
                                                                                LTR Trust mode: In this mode, ltrNumFrames pictures after IDR are automatically marked as LTR. This mode is enabled by setting ltrTrustMode = 1.
                                                                                                Use of LTR Trust mode is strongly discouraged as this mode may be deprecated in future.
                                                                                LTR Per Picture mode: In this mode, client can control whether the current picture should be marked as LTR. Enable this mode by setting
                                                                                                      ltrTrustMode = 0 and ltrMarkFrame = 1 for the picture to be marked as LTR. This is the preferred mode
                                                                                                      for using LTR.
                                                                                Note that LTRs are not supported if encoding session is configured with B-frames */
-    uint32_t qpPrimeYZeroTransformBypassFlag :1;                    /**< [in]: To enable lossless encode set this to 1, set QP to 0 and RC_mode to NV_ENC_PARAMS_RC_CONSTQP and profile to HIGH_444_PREDICTIVE_PROFILE.
+    uint32_t qpPrimeYZeroTransformBypassFlag : 1;                    /**< [in]: To enable lossless encode set this to 1, set QP to 0 and RC_mode to NV_ENC_PARAMS_RC_CONSTQP and profile to HIGH_444_PREDICTIVE_PROFILE.
                                                                                Check support for lossless encoding using ::NV_ENC_CAPS_SUPPORT_LOSSLESS_ENCODE caps.  */
-    uint32_t useConstrainedIntraPred   :1;                          /**< [in]: Set 1 to enable constrained intra prediction. */
-    uint32_t enableFillerDataInsertion :1;                          /**< [in]: Set to 1 to enable insertion of filler data in the bitstream.
+    uint32_t useConstrainedIntraPred   : 1;                         /**< [in]: Set 1 to enable constrained intra prediction. */
+    uint32_t enableFillerDataInsertion : 1;                          /**< [in]: Set to 1 to enable insertion of filler data in the bitstream.
                                                                                This flag will take effect only when one of the CBR rate
                                                                                control modes (NV_ENC_PARAMS_RC_CBR, NV_ENC_PARAMS_RC_CBR_HQ,
                                                                                NV_ENC_PARAMS_RC_CBR_LOWDELAY_HQ) is in use and both
@@ -1438,9 +1438,9 @@ typedef struct _NV_ENC_CONFIG_H264
                                                                                NV_ENC_INITIALIZE_PARAMS::enableOutputInVidmem is also set
                                                                                is currently not supported and will make ::NvEncInitializeEncoder()
                                                                                return an error. */
-    uint32_t disableSVCPrefixNalu      :1;                          /**< [in]: Set to 1 to disable writing of SVC Prefix NALU preceding each slice in bitstream.
+    uint32_t disableSVCPrefixNalu      : 1;                          /**< [in]: Set to 1 to disable writing of SVC Prefix NALU preceding each slice in bitstream.
                                                                                Applicable only when temporal SVC is enabled (NV_ENC_CONFIG_H264::enableTemporalSVC = 1). */
-    uint32_t enableScalabilityInfoSEI  :1;                          /**< [in]: Set to 1 to enable writing of Scalability Information SEI message preceding each IDR picture in bitstream 
+    uint32_t enableScalabilityInfoSEI  : 1;                          /**< [in]: Set to 1 to enable writing of Scalability Information SEI message preceding each IDR picture in bitstream
                                                                                Applicable only when temporal SVC is enabled (NV_ENC_CONFIG_H264::enableTemporalSVC = 1). */
     uint32_t singleSliceIntraRefresh : 1;                           /**< [in]: Set to 1 to maintain single slice in frames during intra refresh.
                                                                                Check support for single slice intra refresh using ::NV_ENC_CAPS_SINGLE_SLICE_INTRA_REFRESH caps.
@@ -1449,9 +1449,9 @@ typedef struct _NV_ENC_CONFIG_H264
     uint32_t level;                                                 /**< [in]: Specifies the encoding level. Client is recommended to set this to NV_ENC_LEVEL_AUTOSELECT in order to enable the NvEncodeAPI interface to select the correct level. */
     uint32_t idrPeriod;                                             /**< [in]: Specifies the IDR interval. If not set, this is made equal to gopLength in NV_ENC_CONFIG.Low latency application client can set IDR interval to NVENC_INFINITE_GOPLENGTH so that IDR frames are not inserted automatically. */
     uint32_t separateColourPlaneFlag;                               /**< [in]: Set to 1 to enable 4:4:4 separate colour planes */
-    uint32_t disableDeblockingFilterIDC;                            /**< [in]: Specifies the deblocking filter mode. Permissible value range: [0,2]. This flag corresponds 
-                                                                               to the flag disable_deblocking_filter_idc specified in section 7.4.3 of H.264 specification, 
-                                                                               which specifies whether the operation of the deblocking filter shall be disabled across some 
+    uint32_t disableDeblockingFilterIDC;                            /**< [in]: Specifies the deblocking filter mode. Permissible value range: [0,2]. This flag corresponds
+                                                                               to the flag disable_deblocking_filter_idc specified in section 7.4.3 of H.264 specification,
+                                                                               which specifies whether the operation of the deblocking filter shall be disabled across some
                                                                                block edges of the slice and specifies for which edges the filtering is disabled. See section
                                                                                7.4.3 of H.264 specification for more details.*/
     uint32_t numTemporalLayers;                                     /**< [in]: Specifies number of temporal layers to be used for hierarchical coding / temporal SVC. Valid value range is [1,::NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS] */
@@ -1465,7 +1465,7 @@ typedef struct _NV_ENC_CONFIG_H264
     uint32_t                            intraRefreshPeriod;         /**< [in]: Specifies the interval between successive intra refresh if enableIntrarefresh is set. Requires enableIntraRefresh to be set.
                                                                                Will be disabled if NV_ENC_CONFIG::gopLength is not set to NVENC_INFINITE_GOPLENGTH. */
     uint32_t                            intraRefreshCnt;            /**< [in]: Specifies the length of intra refresh in number of frames for periodic intra refresh. This value should be smaller than intraRefreshPeriod */
-    uint32_t                            maxNumRefFrames;            /**< [in]: Specifies the DPB size used for encoding. Setting it to 0 will let driver use the default DPB size. 
+    uint32_t                            maxNumRefFrames;            /**< [in]: Specifies the DPB size used for encoding. Setting it to 0 will let driver use the default DPB size.
                                                                                The low latency application which wants to invalidate reference frame as an error resilience tool
                                                                                is recommended to use a large DPB size so that the encoder can keep old reference frames which can be used if recent
                                                                                frames are invalidated. */
@@ -1483,7 +1483,7 @@ typedef struct _NV_ENC_CONFIG_H264
                                                                                In "LTR Trust" mode (ltrTrustMode = 1), encoder will mark the first ltrNumFrames base layer reference frames within each IDR interval as LTR.
                                                                                In "LTR Per Picture" mode (ltrTrustMode = 0 and ltrMarkFrame = 1), ltrNumFrames specifies maximum number of LTR frames in DPB. */
     uint32_t                            ltrTrustMode;               /**< [in]: Specifies the LTR operating mode. See comments near NV_ENC_CONFIG_H264::enableLTR for description of the two modes.
-                                                                               Set to 1 to use "LTR Trust" mode of LTR operation. Clients are discouraged to use "LTR Trust" mode as this mode may 
+                                                                               Set to 1 to use "LTR Trust" mode of LTR operation. Clients are discouraged to use "LTR Trust" mode as this mode may
                                                                                be deprecated in future releases.
                                                                                Set to 0 when using "LTR Per Picture" mode of LTR operation. */
     uint32_t                            chromaFormatIDC;            /**< [in]: Specifies the chroma format. Should be set to 1 for yuv420 input, 3 for yuv444 input.
@@ -1492,12 +1492,12 @@ typedef struct _NV_ENC_CONFIG_H264
                                                                                Defaut value of this field is NV_ENC_CAPS::NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS. Note that the value NV_ENC_CONFIG_H264::maxNumRefFrames should
                                                                                be greater than or equal to (NV_ENC_CONFIG_H264::maxTemporalLayers - 2) * 2, for NV_ENC_CONFIG_H264::maxTemporalLayers >= 2.*/
     NV_ENC_BFRAME_REF_MODE              useBFramesAsRef;            /**< [in]: Specifies the B-Frame as reference mode. Check support for useBFramesAsRef mode using ::NV_ENC_CAPS_SUPPORT_BFRAME_REF_MODE caps.*/
-    NV_ENC_NUM_REF_FRAMES               numRefL0;                   /**< [in]: Specifies max number of reference frames in reference picture list L0, that can be used by hardware for prediction of a frame. 
+    NV_ENC_NUM_REF_FRAMES               numRefL0;                   /**< [in]: Specifies max number of reference frames in reference picture list L0, that can be used by hardware for prediction of a frame.
                                                                                Check support for numRefL0 using ::NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES caps. */
-    NV_ENC_NUM_REF_FRAMES               numRefL1;                   /**< [in]: Specifies max number of reference frames in reference picture list L1, that can be used by hardware for prediction of a frame. 
+    NV_ENC_NUM_REF_FRAMES               numRefL1;                   /**< [in]: Specifies max number of reference frames in reference picture list L1, that can be used by hardware for prediction of a frame.
                                                                                Check support for numRefL1 using ::NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES caps. */
     uint32_t                            reserved1[267];             /**< [in]: Reserved and must be set to 0 */
-    void*                               reserved2[64];              /**< [in]: Reserved and must be set to NULL */
+    void                               *reserved2[64];              /**< [in]: Reserved and must be set to NULL */
 } NV_ENC_CONFIG_H264;
 
 /**
@@ -1510,24 +1510,24 @@ typedef struct _NV_ENC_CONFIG_HEVC
     uint32_t tier;                                                  /**< [in]: Specifies the level tier of the encoded bitstream.*/
     NV_ENC_HEVC_CUSIZE minCUSize;                                   /**< [in]: Specifies the minimum size of luma coding unit.*/
     NV_ENC_HEVC_CUSIZE maxCUSize;                                   /**< [in]: Specifies the maximum size of luma coding unit. Currently NVENC SDK only supports maxCUSize equal to NV_ENC_HEVC_CUSIZE_32x32.*/
-    uint32_t useConstrainedIntraPred               :1;              /**< [in]: Set 1 to enable constrained intra prediction. */
-    uint32_t disableDeblockAcrossSliceBoundary     :1;              /**< [in]: Set 1 to disable in loop filtering across slice boundary.*/
-    uint32_t outputBufferingPeriodSEI              :1;              /**< [in]: Set 1 to write SEI buffering period syntax in the bitstream */
-    uint32_t outputPictureTimingSEI                :1;              /**< [in]: Set 1 to write SEI picture timing syntax in the bitstream */
-    uint32_t outputAUD                             :1;              /**< [in]: Set 1 to write Access Unit Delimiter syntax. */
-    uint32_t enableLTR                             :1;              /**< [in]: Set to 1 to enable LTR (Long Term Reference) frame support. LTR can be used in two modes: "LTR Trust" mode and "LTR Per Picture" mode.
+    uint32_t useConstrainedIntraPred               : 1;             /**< [in]: Set 1 to enable constrained intra prediction. */
+    uint32_t disableDeblockAcrossSliceBoundary     : 1;             /**< [in]: Set 1 to disable in loop filtering across slice boundary.*/
+    uint32_t outputBufferingPeriodSEI              : 1;             /**< [in]: Set 1 to write SEI buffering period syntax in the bitstream */
+    uint32_t outputPictureTimingSEI                : 1;             /**< [in]: Set 1 to write SEI picture timing syntax in the bitstream */
+    uint32_t outputAUD                             : 1;             /**< [in]: Set 1 to write Access Unit Delimiter syntax. */
+    uint32_t enableLTR                             : 1;              /**< [in]: Set to 1 to enable LTR (Long Term Reference) frame support. LTR can be used in two modes: "LTR Trust" mode and "LTR Per Picture" mode.
                                                                                LTR Trust mode: In this mode, ltrNumFrames pictures after IDR are automatically marked as LTR. This mode is enabled by setting ltrTrustMode = 1.
                                                                                                Use of LTR Trust mode is strongly discouraged as this mode may be deprecated in future releases.
                                                                                LTR Per Picture mode: In this mode, client can control whether the current picture should be marked as LTR. Enable this mode by setting
                                                                                                      ltrTrustMode = 0 and ltrMarkFrame = 1 for the picture to be marked as LTR. This is the preferred mode
                                                                                                      for using LTR.
                                                                                Note that LTRs are not supported if encoding session is configured with B-frames */
-    uint32_t disableSPSPPS                         :1;              /**< [in]: Set 1 to disable VPS, SPS and PPS signaling in the bitstream. */
-    uint32_t repeatSPSPPS                          :1;              /**< [in]: Set 1 to output VPS,SPS and PPS for every IDR frame.*/
-    uint32_t enableIntraRefresh                    :1;              /**< [in]: Set 1 to enable gradual decoder refresh or intra refresh. If the GOP structure uses B frames this will be ignored */
-    uint32_t chromaFormatIDC                       :2;              /**< [in]: Specifies the chroma format. Should be set to 1 for yuv420 input, 3 for yuv444 input.*/
-    uint32_t pixelBitDepthMinus8                   :3;              /**< [in]: Specifies pixel bit depth minus 8. Should be set to 0 for 8 bit input, 2 for 10 bit input.*/
-    uint32_t enableFillerDataInsertion             :1;              /**< [in]: Set to 1 to enable insertion of filler data in the bitstream.
+    uint32_t disableSPSPPS                         : 1;             /**< [in]: Set 1 to disable VPS, SPS and PPS signaling in the bitstream. */
+    uint32_t repeatSPSPPS                          : 1;             /**< [in]: Set 1 to output VPS,SPS and PPS for every IDR frame.*/
+    uint32_t enableIntraRefresh                    : 1;             /**< [in]: Set 1 to enable gradual decoder refresh or intra refresh. If the GOP structure uses B frames this will be ignored */
+    uint32_t chromaFormatIDC                       : 2;             /**< [in]: Specifies the chroma format. Should be set to 1 for yuv420 input, 3 for yuv444 input.*/
+    uint32_t pixelBitDepthMinus8                   : 3;             /**< [in]: Specifies pixel bit depth minus 8. Should be set to 0 for 8 bit input, 2 for 10 bit input.*/
+    uint32_t enableFillerDataInsertion             : 1;              /**< [in]: Set to 1 to enable insertion of filler data in the bitstream.
                                                                                This flag will take effect only when one of the CBR rate
                                                                                control modes (NV_ENC_PARAMS_RC_CBR, NV_ENC_PARAMS_RC_CBR_HQ,
                                                                                NV_ENC_PARAMS_RC_CBR_LOWDELAY_HQ) is in use and both
@@ -1537,10 +1537,10 @@ typedef struct _NV_ENC_CONFIG_HEVC
                                                                                NV_ENC_INITIALIZE_PARAMS::enableOutputInVidmem is also set
                                                                                is currently not supported and will make ::NvEncInitializeEncoder()
                                                                                return an error. */
-    uint32_t enableConstrainedEncoding             :1;              /**< [in]: Set this to 1 to enable constrainedFrame encoding where each slice in the constrained picture is independent of other slices.
+    uint32_t enableConstrainedEncoding             : 1;              /**< [in]: Set this to 1 to enable constrainedFrame encoding where each slice in the constrained picture is independent of other slices.
                                                                                Constrained encoding works only with rectangular slices.
                                                                                Check support for constrained encoding using ::NV_ENC_CAPS_SUPPORT_CONSTRAINED_ENCODING caps. */
-    uint32_t enableAlphaLayerEncoding              :1;              /**< [in]: Set this to 1 to enable HEVC encode with alpha layer. */
+    uint32_t enableAlphaLayerEncoding              : 1;             /**< [in]: Set this to 1 to enable HEVC encode with alpha layer. */
     uint32_t singleSliceIntraRefresh : 1;                           /**< [in]: Set this to 1 to maintain single slice frames during intra refresh.
                                                                                Check support for single slice intra refresh using ::NV_ENC_CAPS_SINGLE_SLICE_INTRA_REFRESH caps.
                                                                                This flag will be ignored if the value returned for ::NV_ENC_CAPS_SINGLE_SLICE_INTRA_REFRESH caps is false. */
@@ -1567,46 +1567,46 @@ typedef struct _NV_ENC_CONFIG_HEVC
     uint32_t maxTemporalLayersMinus1;                               /**< [in]: Specifies the max temporal layer used for hierarchical coding. */
     NV_ENC_CONFIG_HEVC_VUI_PARAMETERS   hevcVUIParameters;          /**< [in]: Specifies the HEVC video usability info parameters */
     uint32_t ltrTrustMode;                                          /**< [in]: Specifies the LTR operating mode. See comments near NV_ENC_CONFIG_HEVC::enableLTR for description of the two modes.
-                                                                               Set to 1 to use "LTR Trust" mode of LTR operation. Clients are discouraged to use "LTR Trust" mode as this mode may 
+                                                                               Set to 1 to use "LTR Trust" mode of LTR operation. Clients are discouraged to use "LTR Trust" mode as this mode may
                                                                                be deprecated in future releases.
                                                                                Set to 0 when using "LTR Per Picture" mode of LTR operation. */
     NV_ENC_BFRAME_REF_MODE              useBFramesAsRef;            /**< [in]: Specifies the B-Frame as reference mode. Check support for useBFramesAsRef mode using  ::NV_ENC_CAPS_SUPPORT_BFRAME_REF_MODE caps.*/
-    NV_ENC_NUM_REF_FRAMES               numRefL0;                   /**< [in]: Specifies max number of reference frames in reference picture list L0, that can be used by hardware for prediction of a frame. 
+    NV_ENC_NUM_REF_FRAMES               numRefL0;                   /**< [in]: Specifies max number of reference frames in reference picture list L0, that can be used by hardware for prediction of a frame.
                                                                                Check support for numRefL0 using ::NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES caps. */
-    NV_ENC_NUM_REF_FRAMES               numRefL1;                   /**< [in]: Specifies max number of reference frames in reference picture list L1, that can be used by hardware for prediction of a frame. 
+    NV_ENC_NUM_REF_FRAMES               numRefL1;                   /**< [in]: Specifies max number of reference frames in reference picture list L1, that can be used by hardware for prediction of a frame.
                                                                                Check support for numRefL1 using ::NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES caps. */
     uint32_t                            reserved1[214];             /**< [in]: Reserved and must be set to 0.*/
-    void*                               reserved2[64];              /**< [in]: Reserved and must be set to NULL */
+    void                               *reserved2[64];              /**< [in]: Reserved and must be set to NULL */
 } NV_ENC_CONFIG_HEVC;
 
 /**
  * \struct _NV_ENC_CONFIG_H264_MEONLY
  * H264 encoder configuration parameters for ME only Mode
- * 
+ *
  */
 typedef struct _NV_ENC_CONFIG_H264_MEONLY
 {
-    uint32_t disablePartition16x16 :1;                          /**< [in]: Disable Motion Estimation on 16x16 blocks*/
-    uint32_t disablePartition8x16  :1;                          /**< [in]: Disable Motion Estimation on 8x16 blocks*/
-    uint32_t disablePartition16x8  :1;                          /**< [in]: Disable Motion Estimation on 16x8 blocks*/
-    uint32_t disablePartition8x8   :1;                          /**< [in]: Disable Motion Estimation on 8x8 blocks*/
-    uint32_t disableIntraSearch    :1;                          /**< [in]: Disable Intra search during Motion Estimation*/
-    uint32_t bStereoEnable         :1;                          /**< [in]: Enable Stereo Mode for Motion Estimation where each view is independently executed*/
-    uint32_t reserved              :26;                         /**< [in]: Reserved and must be set to 0 */
+    uint32_t disablePartition16x16 : 1;                         /**< [in]: Disable Motion Estimation on 16x16 blocks*/
+    uint32_t disablePartition8x16  : 1;                         /**< [in]: Disable Motion Estimation on 8x16 blocks*/
+    uint32_t disablePartition16x8  : 1;                         /**< [in]: Disable Motion Estimation on 16x8 blocks*/
+    uint32_t disablePartition8x8   : 1;                         /**< [in]: Disable Motion Estimation on 8x8 blocks*/
+    uint32_t disableIntraSearch    : 1;                         /**< [in]: Disable Intra search during Motion Estimation*/
+    uint32_t bStereoEnable         : 1;                         /**< [in]: Enable Stereo Mode for Motion Estimation where each view is independently executed*/
+    uint32_t reserved              : 26;                        /**< [in]: Reserved and must be set to 0 */
     uint32_t reserved1 [255];                                   /**< [in]: Reserved and must be set to 0 */
-    void*    reserved2[64];                                     /**< [in]: Reserved and must be set to NULL */
+    void    *reserved2[64];                                     /**< [in]: Reserved and must be set to NULL */
 } NV_ENC_CONFIG_H264_MEONLY;
 
 
 /**
  * \struct _NV_ENC_CONFIG_HEVC_MEONLY
  * HEVC encoder configuration parameters for ME only Mode
- * 
+ *
  */
 typedef struct _NV_ENC_CONFIG_HEVC_MEONLY
 {
     uint32_t reserved [256];                                   /**< [in]: Reserved and must be set to 0 */
-    void*    reserved1[64];                                     /**< [in]: Reserved and must be set to NULL */
+    void    *reserved1[64];                                     /**< [in]: Reserved and must be set to NULL */
 } NV_ENC_CONFIG_HEVC_MEONLY;
 
 /**
@@ -1641,7 +1641,7 @@ typedef struct _NV_ENC_CONFIG
     NV_ENC_RC_PARAMS                rcParams;                                    /**< [in]: Specifies the rate control parameters for the current encoding session. */
     NV_ENC_CODEC_CONFIG             encodeCodecConfig;                           /**< [in]: Specifies the codec specific config parameters through this union. */
     uint32_t                        reserved [278];                              /**< [in]: Reserved and must be set to 0 */
-    void*                           reserved2[64];                               /**< [in]: Reserved and must be set to NULL */
+    void                           *reserved2[64];                               /**< [in]: Reserved and must be set to NULL */
 } NV_ENC_CONFIG;
 
 /** macro for constructing the version field of ::_NV_ENC_CONFIG */
@@ -1658,7 +1658,7 @@ typedef enum NV_ENC_TUNING_INFO
     NV_ENC_TUNING_INFO_ULTRA_LOW_LATENCY = 3,                                     /**< Tune presets for ultra low latency streaming.*/
     NV_ENC_TUNING_INFO_LOSSLESS          = 4,                                     /**< Tune presets for lossless encoding.*/
     NV_ENC_TUNING_INFO_COUNT                                                      /**< Count number of tuningInfos. Invalid value. */
-}NV_ENC_TUNING_INFO;
+} NV_ENC_TUNING_INFO;
 
 /**
  * \struct _NV_ENC_INITIALIZE_PARAMS
@@ -1677,21 +1677,21 @@ typedef struct _NV_ENC_INITIALIZE_PARAMS
     uint32_t                                   frameRateDen;                    /**< [in]: Specifies the denominator for frame rate used for encoding in frames per second ( Frame rate = frameRateNum / frameRateDen ). */
     uint32_t                                   enableEncodeAsync;               /**< [in]: Set this to 1 to enable asynchronous mode and is expected to use events to get picture completion notification. */
     uint32_t                                   enablePTD;                       /**< [in]: Set this to 1 to enable the Picture Type Decision is be taken by the NvEncodeAPI interface. */
-    uint32_t                                   reportSliceOffsets        :1;    /**< [in]: Set this to 1 to enable reporting slice offsets in ::_NV_ENC_LOCK_BITSTREAM. NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync must be set to 0 to use this feature. Client must set this to 0 if NV_ENC_CONFIG_H264::sliceMode is 1 on Kepler GPUs */
-    uint32_t                                   enableSubFrameWrite       :1;    /**< [in]: Set this to 1 to write out available bitstream to memory at subframe intervals.
+    uint32_t                                   reportSliceOffsets        : 1;   /**< [in]: Set this to 1 to enable reporting slice offsets in ::_NV_ENC_LOCK_BITSTREAM. NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync must be set to 0 to use this feature. Client must set this to 0 if NV_ENC_CONFIG_H264::sliceMode is 1 on Kepler GPUs */
+    uint32_t                                   enableSubFrameWrite       : 1;    /**< [in]: Set this to 1 to write out available bitstream to memory at subframe intervals.
                                                                                            If enableSubFrameWrite = 1, then the hardware encoder returns data as soon as a slice has completed encoding.
-                                                                                           This results in better encoding latency, but the downside is that the application has to keep polling via a call to nvEncLockBitstream API continuously to see if any encoded slice data is available. 
+                                                                                           This results in better encoding latency, but the downside is that the application has to keep polling via a call to nvEncLockBitstream API continuously to see if any encoded slice data is available.
                                                                                            Use this mode if you feel that the marginal reduction in latency from sub-frame encoding is worth the increase in complexity due to CPU-based polling. */
-    uint32_t                                   enableExternalMEHints     :1;    /**< [in]: Set to 1 to enable external ME hints for the current frame. For NV_ENC_INITIALIZE_PARAMS::enablePTD=1 with B frames, programming L1 hints is optional for B frames since Client doesn't know internal GOP structure. 
+    uint32_t                                   enableExternalMEHints     : 1;    /**< [in]: Set to 1 to enable external ME hints for the current frame. For NV_ENC_INITIALIZE_PARAMS::enablePTD=1 with B frames, programming L1 hints is optional for B frames since Client doesn't know internal GOP structure.
                                                                                            NV_ENC_PIC_PARAMS::meHintRefPicDist should preferably be set with enablePTD=1. */
-    uint32_t                                   enableMEOnlyMode          :1;    /**< [in]: Set to 1 to enable ME Only Mode .*/
-    uint32_t                                   enableWeightedPrediction  :1;    /**< [in]: Set this to 1 to enable weighted prediction. Not supported if encode session is configured for B-Frames (i.e. NV_ENC_CONFIG::frameIntervalP > 1 or preset >=P3 when tuningInfo = ::NV_ENC_TUNING_INFO_HIGH_QUALITY or 
+    uint32_t                                   enableMEOnlyMode          : 1;   /**< [in]: Set to 1 to enable ME Only Mode .*/
+    uint32_t                                   enableWeightedPrediction  : 1;    /**< [in]: Set this to 1 to enable weighted prediction. Not supported if encode session is configured for B-Frames (i.e. NV_ENC_CONFIG::frameIntervalP > 1 or preset >=P3 when tuningInfo = ::NV_ENC_TUNING_INFO_HIGH_QUALITY or
                                                                                            tuningInfo = ::NV_ENC_TUNING_INFO_LOSSLESS. This is because preset >=p3 internally enables B frames when tuningInfo = ::NV_ENC_TUNING_INFO_HIGH_QUALITY or ::NV_ENC_TUNING_INFO_LOSSLESS). */
-    uint32_t                                   enableOutputInVidmem      :1;    /**< [in]: Set this to 1 to enable output of NVENC in video memory buffer created by application. This feature is not supported for HEVC ME only mode. */
-    uint32_t                                   reservedBitFields         :26;   /**< [in]: Reserved bitfields and must be set to 0 */
+    uint32_t                                   enableOutputInVidmem      : 1;   /**< [in]: Set this to 1 to enable output of NVENC in video memory buffer created by application. This feature is not supported for HEVC ME only mode. */
+    uint32_t                                   reservedBitFields         : 26;  /**< [in]: Reserved bitfields and must be set to 0 */
     uint32_t                                   privDataSize;                    /**< [in]: Reserved private data buffer size and must be set to 0 */
-    void*                                      privData;                        /**< [in]: Reserved private data buffer and must be set to NULL */
-    NV_ENC_CONFIG*                             encodeConfig;                    /**< [in]: Specifies the advanced codec specific structure. If client has sent a valid codec config structure, it will override parameters set by the NV_ENC_INITIALIZE_PARAMS::presetGUID parameter. If set to NULL the NvEncodeAPI interface will use the NV_ENC_INITIALIZE_PARAMS::presetGUID to set the codec specific parameters.
+    void                                      *privData;                        /**< [in]: Reserved private data buffer and must be set to NULL */
+    NV_ENC_CONFIG                             *encodeConfig;                    /**< [in]: Specifies the advanced codec specific structure. If client has sent a valid codec config structure, it will override parameters set by the NV_ENC_INITIALIZE_PARAMS::presetGUID parameter. If set to NULL the NvEncodeAPI interface will use the NV_ENC_INITIALIZE_PARAMS::presetGUID to set the codec specific parameters.
                                                                                            Client can also optionally query the NvEncodeAPI interface to get codec specific parameters for a presetGUID using ::NvEncGetEncodePresetConfig() API. It can then modify (if required) some of the codec config parameters and send down a custom config structure as part of ::_NV_ENC_INITIALIZE_PARAMS.
                                                                                            Even in this case client is recommended to pass the same preset guid it has used in ::NvEncGetEncodePresetConfig() API to query the config structure; as NV_ENC_INITIALIZE_PARAMS::presetGUID. This will not override the custom config structure but will be used to determine other Encoder HW specific parameters not exposed in the API. */
     uint32_t                                   maxEncodeWidth;                  /**< [in]: Maximum encode width to be used for current Encode session.
@@ -1704,7 +1704,7 @@ typedef struct _NV_ENC_INITIALIZE_PARAMS
     NV_ENC_TUNING_INFO                         tuningInfo;                      /**< [in]: Tuning Info of NVENC encoding(TuningInfo is not applicable to H264 and HEVC meonly mode). */
     NV_ENC_BUFFER_FORMAT                       bufferFormat;                    /**< [in]: Specifies input buffer format. Client should set input buffer format only when D3D12 interface type is used. */
     uint32_t                                   reserved[287];                   /**< [in]: Reserved and must be set to 0 */
-    void*                                      reserved2[64];                   /**< [in]: Reserved and must be set to NULL */
+    void                                      *reserved2[64];                   /**< [in]: Reserved and must be set to NULL */
 } NV_ENC_INITIALIZE_PARAMS;
 
 /** macro for constructing the version field of ::_NV_ENC_INITIALIZE_PARAMS */
@@ -1733,13 +1733,13 @@ typedef struct _NV_ENC_RECONFIGURE_PARAMS
                                                                                            configuration is incompatible with the existing
                                                                                            configuration (e.g. the new configuration results in
                                                                                            a change in the GOP structure). */
-    uint32_t                                    resetEncoder            :1;     /**< [in]: This resets the rate control states and other internal encoder states. This should be used only with an IDR frame.
+    uint32_t                                    resetEncoder            : 1;     /**< [in]: This resets the rate control states and other internal encoder states. This should be used only with an IDR frame.
                                                                                            If NV_ENC_INITIALIZE_PARAMS::enablePTD is set to 1, encoder will force the frame type to IDR */
-    uint32_t                                    forceIDR                :1;     /**< [in]: Encode the current picture as an IDR picture. This flag is only valid when Picture type decision is taken by the Encoder
+    uint32_t                                    forceIDR                : 1;     /**< [in]: Encode the current picture as an IDR picture. This flag is only valid when Picture type decision is taken by the Encoder
                                                                                            [_NV_ENC_INITIALIZE_PARAMS::enablePTD == 1]. */
-    uint32_t                                    reserved                :30;
+    uint32_t                                    reserved                : 30;
 
-}NV_ENC_RECONFIGURE_PARAMS;
+} NV_ENC_RECONFIGURE_PARAMS;
 
 /** macro for constructing the version field of ::_NV_ENC_RECONFIGURE_PARAMS */
 #define NV_ENC_RECONFIGURE_PARAMS_VER (NVENCAPI_STRUCT_VERSION(1) | ( 1<<31 ))
@@ -1747,14 +1747,14 @@ typedef struct _NV_ENC_RECONFIGURE_PARAMS
 /**
  * \struct _NV_ENC_PRESET_CONFIG
  * Encoder preset config
- */ 
+ */
 typedef struct _NV_ENC_PRESET_CONFIG
 {
     uint32_t      version;                               /**< [in]:  Struct version. Must be set to ::NV_ENC_PRESET_CONFIG_VER. */
     NV_ENC_CONFIG presetCfg;                             /**< [out]: preset config returned by the Nvidia Video Encoder interface. */
     uint32_t      reserved1[255];                        /**< [in]: Reserved and must be set to 0 */
-    void*         reserved2[64];                         /**< [in]: Reserved and must be set to NULL */
-}NV_ENC_PRESET_CONFIG;
+    void         *reserved2[64];                         /**< [in]: Reserved and must be set to NULL */
+} NV_ENC_PRESET_CONFIG;
 
 /** macro for constructing the version field of ::_NV_ENC_PRESET_CONFIG */
 #define NV_ENC_PRESET_CONFIG_VER (NVENCAPI_STRUCT_VERSION(4) | ( 1<<31 ))
@@ -1763,7 +1763,7 @@ typedef struct _NV_ENC_PRESET_CONFIG
 /**
  * \struct _NV_ENC_PIC_PARAMS_MVC
  * MVC-specific parameters to be sent on a per-frame basis.
- */ 
+ */
 typedef struct _NV_ENC_PIC_PARAMS_MVC
 {
     uint32_t version;                                    /**< [in]: Struct version. Must be set to ::NV_ENC_PIC_PARAMS_MVC_VER. */
@@ -1771,8 +1771,8 @@ typedef struct _NV_ENC_PIC_PARAMS_MVC
     uint32_t temporalID;                                 /**< [in]: Specifies the temporal ID associated with the current input view. */
     uint32_t priorityID;                                 /**< [in]: Specifies the priority ID associated with the current input view. Reserved and ignored by the NvEncodeAPI interface. */
     uint32_t reserved1[12];                              /**< [in]: Reserved and must be set to 0. */
-    void*    reserved2[8];                              /**< [in]: Reserved and must be set to NULL. */
-}NV_ENC_PIC_PARAMS_MVC;
+    void    *reserved2[8];                              /**< [in]: Reserved and must be set to NULL. */
+} NV_ENC_PIC_PARAMS_MVC;
 
 /** macro for constructing the version field of ::_NV_ENC_PIC_PARAMS_MVC */
 #define NV_ENC_PIC_PARAMS_MVC_VER NVENCAPI_STRUCT_VERSION(1)
@@ -1781,12 +1781,12 @@ typedef struct _NV_ENC_PIC_PARAMS_MVC
 /**
  * \union _NV_ENC_PIC_PARAMS_H264_EXT
  * H264 extension  picture parameters
- */ 
+ */
 typedef union _NV_ENC_PIC_PARAMS_H264_EXT
 {
     NV_ENC_PIC_PARAMS_MVC mvcPicParams;                  /**< [in]: Specifies the MVC picture parameters. */
     uint32_t reserved1[32];                              /**< [in]: Reserved and must be set to 0.        */
-}NV_ENC_PIC_PARAMS_H264_EXT;
+} NV_ENC_PIC_PARAMS_H264_EXT;
 
 /**
  * \struct _NV_ENC_SEI_PAYLOAD
@@ -1804,27 +1804,27 @@ typedef struct _NV_ENC_SEI_PAYLOAD
 /**
  * \struct _NV_ENC_PIC_PARAMS_H264
  * H264 specific enc pic params. sent on a per frame basis.
- */ 
+ */
 typedef struct _NV_ENC_PIC_PARAMS_H264
 {
     uint32_t displayPOCSyntax;                           /**< [in]: Specifies the display POC syntax This is required to be set if client is handling the picture type decision. */
     uint32_t reserved3;                                  /**< [in]: Reserved and must be set to 0 */
     uint32_t refPicFlag;                                 /**< [in]: Set to 1 for a reference picture. This is ignored if NV_ENC_INITIALIZE_PARAMS::enablePTD is set to 1. */
     uint32_t colourPlaneId;                              /**< [in]: Specifies the colour plane ID associated with the current input. */
-    uint32_t forceIntraRefreshWithFrameCnt;              /**< [in]: Forces an intra refresh with duration equal to intraRefreshFrameCnt. 
-                                                                    When outputRecoveryPointSEI is set this is value is used for recovery_frame_cnt in recovery point SEI message 
+    uint32_t forceIntraRefreshWithFrameCnt;              /**< [in]: Forces an intra refresh with duration equal to intraRefreshFrameCnt.
+                                                                    When outputRecoveryPointSEI is set this is value is used for recovery_frame_cnt in recovery point SEI message
                                                                     forceIntraRefreshWithFrameCnt cannot be used if B frames are used in the GOP structure specified */
-    uint32_t constrainedFrame           :1;              /**< [in]: Set to 1 if client wants to encode this frame with each slice completely independent of other slices in the frame. 
+    uint32_t constrainedFrame           : 1;              /**< [in]: Set to 1 if client wants to encode this frame with each slice completely independent of other slices in the frame.
                                                                     NV_ENC_INITIALIZE_PARAMS::enableConstrainedEncoding should be set to 1 */
-    uint32_t sliceModeDataUpdate        :1;              /**< [in]: Set to 1 if client wants to change the sliceModeData field to specify new sliceSize Parameter
+    uint32_t sliceModeDataUpdate        : 1;              /**< [in]: Set to 1 if client wants to change the sliceModeData field to specify new sliceSize Parameter
                                                                     When forceIntraRefreshWithFrameCnt is set it will have priority over sliceMode setting */
-    uint32_t ltrMarkFrame               :1;              /**< [in]: Set to 1 if client wants to mark this frame as LTR */
-    uint32_t ltrUseFrames               :1;              /**< [in]: Set to 1 if client allows encoding this frame using the LTR frames specified in ltrFrameBitmap */
-    uint32_t reservedBitFields          :28;             /**< [in]: Reserved bit fields and must be set to 0 */
-    uint8_t* sliceTypeData;                              /**< [in]: Deprecated. */
+    uint32_t ltrMarkFrame               : 1;             /**< [in]: Set to 1 if client wants to mark this frame as LTR */
+    uint32_t ltrUseFrames               : 1;             /**< [in]: Set to 1 if client allows encoding this frame using the LTR frames specified in ltrFrameBitmap */
+    uint32_t reservedBitFields          : 28;            /**< [in]: Reserved bit fields and must be set to 0 */
+    uint8_t *sliceTypeData;                              /**< [in]: Deprecated. */
     uint32_t sliceTypeArrayCnt;                          /**< [in]: Deprecated. */
     uint32_t seiPayloadArrayCnt;                         /**< [in]: Specifies the number of elements allocated in  seiPayloadArray array. */
-    NV_ENC_SEI_PAYLOAD* seiPayloadArray;                 /**< [in]: Array of SEI payloads which will be inserted for this frame. */
+    NV_ENC_SEI_PAYLOAD *seiPayloadArray;                 /**< [in]: Array of SEI payloads which will be inserted for this frame. */
     uint32_t sliceMode;                                  /**< [in]: This parameter in conjunction with sliceModeData specifies the way in which the picture is divided into slices
                                                                     sliceMode = 0 MB based slices, sliceMode = 1 Byte based slices, sliceMode = 2 MB row based slices, sliceMode = 3, numSlices in Picture
                                                                     When forceIntraRefreshWithFrameCnt is set it will have priority over sliceMode setting
@@ -1840,10 +1840,10 @@ typedef struct _NV_ENC_PIC_PARAMS_H264
     uint32_t forceIntraSliceCount;                       /**< [in]: Specifies the number of slices to be forced to Intra in the current picture.
                                                                     This option along with forceIntraSliceIdx[] array needs to be used with sliceMode = 3 only */
     uint32_t *forceIntraSliceIdx;                        /**< [in]: Slice indices to be forced to intra in the current picture. Each slice index should be <= num_slices_in_picture -1. Index starts from 0 for first slice.
-                                                                    The number of entries in this array should be equal to forceIntraSliceCount */															
+                                                                    The number of entries in this array should be equal to forceIntraSliceCount */
     NV_ENC_PIC_PARAMS_H264_EXT h264ExtPicParams;         /**< [in]: Specifies the H264 extension config parameters using this config. */
     uint32_t reserved [210];                             /**< [in]: Reserved and must be set to 0. */
-    void*    reserved2[61];                              /**< [in]: Reserved and must be set to NULL. */
+    void    *reserved2[61];                              /**< [in]: Reserved and must be set to NULL. */
 } NV_ENC_PIC_PARAMS_H264;
 
 /**
@@ -1855,18 +1855,18 @@ typedef struct _NV_ENC_PIC_PARAMS_HEVC
     uint32_t displayPOCSyntax;                           /**< [in]: Specifies the display POC syntax This is required to be set if client is handling the picture type decision. */
     uint32_t refPicFlag;                                 /**< [in]: Set to 1 for a reference picture. This is ignored if NV_ENC_INITIALIZE_PARAMS::enablePTD is set to 1. */
     uint32_t temporalId;                                 /**< [in]: Specifies the temporal id of the picture */
-    uint32_t forceIntraRefreshWithFrameCnt;              /**< [in]: Forces an intra refresh with duration equal to intraRefreshFrameCnt. 
-                                                                    When outputRecoveryPointSEI is set this is value is used for recovery_frame_cnt in recovery point SEI message 
+    uint32_t forceIntraRefreshWithFrameCnt;              /**< [in]: Forces an intra refresh with duration equal to intraRefreshFrameCnt.
+                                                                    When outputRecoveryPointSEI is set this is value is used for recovery_frame_cnt in recovery point SEI message
                                                                     forceIntraRefreshWithFrameCnt cannot be used if B frames are used in the GOP structure specified */
-    uint32_t constrainedFrame           :1;              /**< [in]: Set to 1 if client wants to encode this frame with each slice completely independent of other slices in the frame. 
+    uint32_t constrainedFrame           : 1;              /**< [in]: Set to 1 if client wants to encode this frame with each slice completely independent of other slices in the frame.
                                                                     NV_ENC_INITIALIZE_PARAMS::enableConstrainedEncoding should be set to 1 */
-    uint32_t sliceModeDataUpdate        :1;              /**< [in]: Set to 1 if client wants to change the sliceModeData field to specify new sliceSize Parameter
+    uint32_t sliceModeDataUpdate        : 1;              /**< [in]: Set to 1 if client wants to change the sliceModeData field to specify new sliceSize Parameter
                                                                     When forceIntraRefreshWithFrameCnt is set it will have priority over sliceMode setting */
-    uint32_t ltrMarkFrame               :1;              /**< [in]: Set to 1 if client wants to mark this frame as LTR */
-    uint32_t ltrUseFrames               :1;              /**< [in]: Set to 1 if client allows encoding this frame using the LTR frames specified in ltrFrameBitmap */
-    uint32_t reservedBitFields          :28;             /**< [in]: Reserved bit fields and must be set to 0 */
-    uint8_t* sliceTypeData;                              /**< [in]: Array which specifies the slice type used to force intra slice for a particular slice. Currently supported only for NV_ENC_CONFIG_H264::sliceMode == 3. 
-                                                                    Client should allocate array of size sliceModeData where sliceModeData is specified in field of ::_NV_ENC_CONFIG_H264 
+    uint32_t ltrMarkFrame               : 1;             /**< [in]: Set to 1 if client wants to mark this frame as LTR */
+    uint32_t ltrUseFrames               : 1;             /**< [in]: Set to 1 if client allows encoding this frame using the LTR frames specified in ltrFrameBitmap */
+    uint32_t reservedBitFields          : 28;            /**< [in]: Reserved bit fields and must be set to 0 */
+    uint8_t *sliceTypeData;                              /**< [in]: Array which specifies the slice type used to force intra slice for a particular slice. Currently supported only for NV_ENC_CONFIG_H264::sliceMode == 3.
+                                                                    Client should allocate array of size sliceModeData where sliceModeData is specified in field of ::_NV_ENC_CONFIG_H264
                                                                     Array element with index n corresponds to nth slice. To force a particular slice to intra client should set corresponding array element to NV_ENC_SLICE_TYPE_I
                                                                     all other array elements should be set to NV_ENC_SLICE_TYPE_DEFAULT */
     uint32_t sliceTypeArrayCnt;                          /**< [in]: Client should set this to the number of elements allocated in sliceTypeData array. If sliceTypeData is NULL then this should be set to 0 */
@@ -1884,9 +1884,9 @@ typedef struct _NV_ENC_PIC_PARAMS_HEVC
     uint32_t ltrUsageMode;                               /**< [in]: Not supported. Reserved for future use and must be set to 0. */
     uint32_t seiPayloadArrayCnt;                         /**< [in]: Specifies the number of elements allocated in  seiPayloadArray array. */
     uint32_t reserved;                                   /**< [in]: Reserved and must be set to 0. */
-    NV_ENC_SEI_PAYLOAD* seiPayloadArray;                 /**< [in]: Array of SEI payloads which will be inserted for this frame. */
+    NV_ENC_SEI_PAYLOAD *seiPayloadArray;                 /**< [in]: Array of SEI payloads which will be inserted for this frame. */
     uint32_t reserved2 [244];                             /**< [in]: Reserved and must be set to 0. */
-    void*    reserved3[61];                              /**< [in]: Reserved and must be set to NULL. */
+    void    *reserved3[61];                              /**< [in]: Reserved and must be set to NULL. */
 } NV_ENC_PIC_PARAMS_HEVC;
 
 /**
@@ -1911,44 +1911,44 @@ typedef struct _NV_ENC_PIC_PARAMS
     uint32_t                                    inputPitch;                     /**< [in]: Specifies the input buffer pitch. If pitch value is not known, set this to inputWidth. */
     uint32_t                                    encodePicFlags;                 /**< [in]: Specifies bit-wise OR of encode picture flags. See ::NV_ENC_PIC_FLAGS enum. */
     uint32_t                                    frameIdx;                       /**< [in]: Specifies the frame index associated with the input frame [optional]. */
-    uint64_t                                    inputTimeStamp;                 /**< [in]: Specifies opaque data which is associated with the encoded frame, but not actually encoded in the output bitstream. 
-                                                                                           This opaque data can be used later to uniquely refer to the corresponding encoded frame. For example, it can be used 
+    uint64_t                                    inputTimeStamp;                 /**< [in]: Specifies opaque data which is associated with the encoded frame, but not actually encoded in the output bitstream.
+                                                                                           This opaque data can be used later to uniquely refer to the corresponding encoded frame. For example, it can be used
                                                                                            for identifying the frame to be invalidated in the reference picture buffer, if lost at the client. */
     uint64_t                                    inputDuration;                  /**< [in]: Specifies duration of the input picture */
     NV_ENC_INPUT_PTR                            inputBuffer;                    /**< [in]: Specifies the input buffer pointer. Client must use a pointer obtained from ::NvEncCreateInputBuffer() or ::NvEncMapInputResource() APIs.*/
-    NV_ENC_OUTPUT_PTR                           outputBitstream;                /**< [in]: Specifies the output buffer pointer. 
-                                                                                           If NV_ENC_INITIALIZE_PARAMS::enableOutputInVidmem is set to 0, specifies the pointer to output buffer. Client should use a pointer obtained from ::NvEncCreateBitstreamBuffer() API. 
-                                                                                           If NV_ENC_INITIALIZE_PARAMS::enableOutputInVidmem is set to 1, client should allocate buffer in video memory for NV_ENC_ENCODE_OUT_PARAMS struct and encoded bitstream data. Client 
-                                                                                           should use a pointer obtained from ::NvEncMapInputResource() API, when mapping this output buffer and assign it to NV_ENC_PIC_PARAMS::outputBitstream. 
-                                                                                           First 256 bytes of this buffer should be interpreted as NV_ENC_ENCODE_OUT_PARAMS struct followed by encoded bitstream data. Recommended size for output buffer is sum of size of 
-                                                                                           NV_ENC_ENCODE_OUT_PARAMS struct and twice the input frame size for lower resolution eg. CIF and 1.5 times the input frame size for higher resolutions. If encoded bitstream size is 
-                                                                                           greater than the allocated buffer size for encoded bitstream, then the output buffer will have encoded bitstream data equal to buffer size. All CUDA operations on this buffer must use 
+    NV_ENC_OUTPUT_PTR                           outputBitstream;                /**< [in]: Specifies the output buffer pointer.
+                                                                                           If NV_ENC_INITIALIZE_PARAMS::enableOutputInVidmem is set to 0, specifies the pointer to output buffer. Client should use a pointer obtained from ::NvEncCreateBitstreamBuffer() API.
+                                                                                           If NV_ENC_INITIALIZE_PARAMS::enableOutputInVidmem is set to 1, client should allocate buffer in video memory for NV_ENC_ENCODE_OUT_PARAMS struct and encoded bitstream data. Client
+                                                                                           should use a pointer obtained from ::NvEncMapInputResource() API, when mapping this output buffer and assign it to NV_ENC_PIC_PARAMS::outputBitstream.
+                                                                                           First 256 bytes of this buffer should be interpreted as NV_ENC_ENCODE_OUT_PARAMS struct followed by encoded bitstream data. Recommended size for output buffer is sum of size of
+                                                                                           NV_ENC_ENCODE_OUT_PARAMS struct and twice the input frame size for lower resolution eg. CIF and 1.5 times the input frame size for higher resolutions. If encoded bitstream size is
+                                                                                           greater than the allocated buffer size for encoded bitstream, then the output buffer will have encoded bitstream data equal to buffer size. All CUDA operations on this buffer must use
                                                                                            the default stream. */
-    void*                                       completionEvent;                /**< [in]: Specifies an event to be signaled on completion of encoding of this Frame [only if operating in Asynchronous mode]. Each output buffer should be associated with a distinct event pointer. */
+    void                                       *completionEvent;                /**< [in]: Specifies an event to be signaled on completion of encoding of this Frame [only if operating in Asynchronous mode]. Each output buffer should be associated with a distinct event pointer. */
     NV_ENC_BUFFER_FORMAT                        bufferFmt;                      /**< [in]: Specifies the input buffer format. */
     NV_ENC_PIC_STRUCT                           pictureStruct;                  /**< [in]: Specifies structure of the input picture. */
     NV_ENC_PIC_TYPE                             pictureType;                    /**< [in]: Specifies input picture type. Client required to be set explicitly by the client if the client has not set NV_ENC_INITALIZE_PARAMS::enablePTD to 1 while calling NvInitializeEncoder. */
     NV_ENC_CODEC_PIC_PARAMS                     codecPicParams;                 /**< [in]: Specifies the codec specific per-picture encoding parameters. */
     NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE meHintCountsPerBlock[2];        /**< [in]: For H264 and Hevc, specifies the number of hint candidates per block per direction for the current frame. meHintCountsPerBlock[0] is for L0 predictors and meHintCountsPerBlock[1] is for L1 predictors.
                                                                                            The candidate count in NV_ENC_PIC_PARAMS::meHintCountsPerBlock[lx] must never exceed NV_ENC_INITIALIZE_PARAMS::maxMEHintCountsPerBlock[lx] provided during encoder initialization. */
-    NVENC_EXTERNAL_ME_HINT*                     meExternalHints;                /**< [in]: For H264 and Hevc, Specifies the pointer to ME external hints for the current frame. The size of ME hint buffer should be equal to number of macroblocks * the total number of candidates per macroblock.
-                                                                                           The total number of candidates per MB per direction = 1*meHintCountsPerBlock[Lx].numCandsPerBlk16x16 + 2*meHintCountsPerBlock[Lx].numCandsPerBlk16x8 + 2*meHintCountsPerBlock[Lx].numCandsPerBlk8x8  
+    NVENC_EXTERNAL_ME_HINT                     *meExternalHints;                /**< [in]: For H264 and Hevc, Specifies the pointer to ME external hints for the current frame. The size of ME hint buffer should be equal to number of macroblocks * the total number of candidates per macroblock.
+                                                                                           The total number of candidates per MB per direction = 1*meHintCountsPerBlock[Lx].numCandsPerBlk16x16 + 2*meHintCountsPerBlock[Lx].numCandsPerBlk16x8 + 2*meHintCountsPerBlock[Lx].numCandsPerBlk8x8
                                                                                            + 4*meHintCountsPerBlock[Lx].numCandsPerBlk8x8. For frames using bidirectional ME , the total number of candidates for single macroblock is sum of total number of candidates per MB for each direction (L0 and L1) */
     uint32_t                                    reserved1[6];                    /**< [in]: Reserved and must be set to 0 */
-    void*                                       reserved2[2];                    /**< [in]: Reserved and must be set to NULL */
-    int8_t                                     *qpDeltaMap;                      /**< [in]: Specifies the pointer to signed byte array containing value per MB for H264 and per CTB for HEVC in raster scan order for the current picture, which will be interpreted depending on NV_ENC_RC_PARAMS::qpMapMode. 
+    void                                       *reserved2[2];                    /**< [in]: Reserved and must be set to NULL */
+    int8_t                                     *qpDeltaMap;                      /**< [in]: Specifies the pointer to signed byte array containing value per MB for H264 and per CTB for HEVC in raster scan order for the current picture, which will be interpreted depending on NV_ENC_RC_PARAMS::qpMapMode.
                                                                                             If NV_ENC_RC_PARAMS::qpMapMode is NV_ENC_QP_MAP_DELTA, qpDeltaMap specifies QP modifier per MB for H264 and per CTB for HEVC. This QP modifier will be applied on top of the QP chosen by rate control.
-                                                                                            If NV_ENC_RC_PARAMS::qpMapMode is NV_ENC_QP_MAP_EMPHASIS, qpDeltaMap specifies Emphasis Level Map per MB for H264. This level value along with QP chosen by rate control is used to 
+                                                                                            If NV_ENC_RC_PARAMS::qpMapMode is NV_ENC_QP_MAP_EMPHASIS, qpDeltaMap specifies Emphasis Level Map per MB for H264. This level value along with QP chosen by rate control is used to
                                                                                             compute the QP modifier, which in turn is applied on top of QP chosen by rate control.
                                                                                             If NV_ENC_RC_PARAMS::qpMapMode is NV_ENC_QP_MAP_DISABLED, value in qpDeltaMap will be ignored.*/
     uint32_t                                    qpDeltaMapSize;                  /**< [in]: Specifies the size in bytes of qpDeltaMap surface allocated by client and pointed to by NV_ENC_PIC_PARAMS::qpDeltaMap. Surface (array) should be picWidthInMbs * picHeightInMbs for H264 and picWidthInCtbs * picHeightInCtbs for HEVC */
     uint32_t                                    reservedBitFields;               /**< [in]: Reserved bitfields and must be set to 0 */
-    uint16_t                                    meHintRefPicDist[2];             /**< [in]: Specifies temporal distance for reference picture (NVENC_EXTERNAL_ME_HINT::refidx = 0) used during external ME with NV_ENC_INITALIZE_PARAMS::enablePTD = 1 . meHintRefPicDist[0] is for L0 hints and meHintRefPicDist[1] is for L1 hints. 
+    uint16_t                                    meHintRefPicDist[2];             /**< [in]: Specifies temporal distance for reference picture (NVENC_EXTERNAL_ME_HINT::refidx = 0) used during external ME with NV_ENC_INITALIZE_PARAMS::enablePTD = 1 . meHintRefPicDist[0] is for L0 hints and meHintRefPicDist[1] is for L1 hints.
                                                                                             If not set, will internally infer distance of 1. Ignored for NV_ENC_INITALIZE_PARAMS::enablePTD = 0 */
     NV_ENC_INPUT_PTR                            alphaBuffer;                     /**< [in]: Specifies the input alpha buffer pointer. Client must use a pointer obtained from ::NvEncCreateInputBuffer() or ::NvEncMapInputResource() APIs.
                                                                                             Applicable only when encoding hevc with alpha layer is enabled. */
     uint32_t                                    reserved3[286];                  /**< [in]: Reserved and must be set to 0 */
-    void*                                       reserved4[59];                   /**< [in]: Reserved and must be set to NULL */
+    void                                       *reserved4[59];                   /**< [in]: Reserved and must be set to NULL */
 } NV_ENC_PIC_PARAMS;
 
 /** Macro for constructing the version field of ::_NV_ENC_PIC_PARAMS */
@@ -1968,25 +1968,25 @@ typedef struct _NV_ENC_MEONLY_PARAMS
     NV_ENC_INPUT_PTR        inputBuffer;                        /**< [in]: Specifies the input buffer pointer. Client must use a pointer obtained from NvEncCreateInputBuffer() or NvEncMapInputResource() APIs. */
     NV_ENC_INPUT_PTR        referenceFrame;                     /**< [in]: Specifies the reference frame pointer */
     NV_ENC_OUTPUT_PTR       mvBuffer;                           /**< [in]: Specifies the output buffer pointer.
-                                                                           If NV_ENC_INITIALIZE_PARAMS::enableOutputInVidmem is set to 0, specifies the pointer to motion vector data buffer allocated by NvEncCreateMVBuffer. 
-                                                                           Client must lock mvBuffer using ::NvEncLockBitstream() API to get the motion vector data. 
-                                                                           If NV_ENC_INITIALIZE_PARAMS::enableOutputInVidmem is set to 1, client should allocate buffer in video memory for storing the motion vector data. The size of this buffer must 
-                                                                           be equal to total number of macroblocks multiplied by size of NV_ENC_H264_MV_DATA struct. Client should use a pointer obtained from ::NvEncMapInputResource() API, when mapping this 
+                                                                           If NV_ENC_INITIALIZE_PARAMS::enableOutputInVidmem is set to 0, specifies the pointer to motion vector data buffer allocated by NvEncCreateMVBuffer.
+                                                                           Client must lock mvBuffer using ::NvEncLockBitstream() API to get the motion vector data.
+                                                                           If NV_ENC_INITIALIZE_PARAMS::enableOutputInVidmem is set to 1, client should allocate buffer in video memory for storing the motion vector data. The size of this buffer must
+                                                                           be equal to total number of macroblocks multiplied by size of NV_ENC_H264_MV_DATA struct. Client should use a pointer obtained from ::NvEncMapInputResource() API, when mapping this
                                                                            output buffer and assign it to NV_ENC_MEONLY_PARAMS::mvBuffer. All CUDA operations on this buffer must use the default stream. */
     NV_ENC_BUFFER_FORMAT    bufferFmt;                          /**< [in]: Specifies the input buffer format. */
-    void*                   completionEvent;                    /**< [in]: Specifies an event to be signaled on completion of motion estimation 
-                                                                           of this Frame [only if operating in Asynchronous mode]. 
+    void                   *completionEvent;                    /**< [in]: Specifies an event to be signaled on completion of motion estimation
+                                                                           of this Frame [only if operating in Asynchronous mode].
                                                                            Each output buffer should be associated with a distinct event pointer. */
     uint32_t                viewID;                             /**< [in]: Specifies left or right viewID if NV_ENC_CONFIG_H264_MEONLY::bStereoEnable is set.
                                                                             viewID can be 0,1 if bStereoEnable is set, 0 otherwise. */
-    NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE 
-                            meHintCountsPerBlock[2];            /**< [in]: Specifies the number of hint candidates per block for the current frame. meHintCountsPerBlock[0] is for L0 predictors.
+    NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE
+    meHintCountsPerBlock[2];            /**< [in]: Specifies the number of hint candidates per block for the current frame. meHintCountsPerBlock[0] is for L0 predictors.
                                                                             The candidate count in NV_ENC_PIC_PARAMS::meHintCountsPerBlock[lx] must never exceed NV_ENC_INITIALIZE_PARAMS::maxMEHintCountsPerBlock[lx] provided during encoder initialization. */
     NVENC_EXTERNAL_ME_HINT  *meExternalHints;                   /**< [in]: Specifies the pointer to ME external hints for the current frame. The size of ME hint buffer should be equal to number of macroblocks * the total number of candidates per macroblock.
-                                                                            The total number of candidates per MB per direction = 1*meHintCountsPerBlock[Lx].numCandsPerBlk16x16 + 2*meHintCountsPerBlock[Lx].numCandsPerBlk16x8 + 2*meHintCountsPerBlock[Lx].numCandsPerBlk8x8  
+                                                                            The total number of candidates per MB per direction = 1*meHintCountsPerBlock[Lx].numCandsPerBlk16x16 + 2*meHintCountsPerBlock[Lx].numCandsPerBlk16x8 + 2*meHintCountsPerBlock[Lx].numCandsPerBlk8x8
                                                                             + 4*meHintCountsPerBlock[Lx].numCandsPerBlk8x8. For frames using bidirectional ME , the total number of candidates for single macroblock is sum of total number of candidates per MB for each direction (L0 and L1) */
     uint32_t                reserved1[243];                     /**< [in]: Reserved and must be set to 0 */
-    void*                   reserved2[59];                      /**< [in]: Reserved and must be set to NULL */
+    void                   *reserved2[59];                      /**< [in]: Reserved and must be set to NULL */
 } NV_ENC_MEONLY_PARAMS;
 
 /** NV_ENC_MEONLY_PARAMS struct version*/
@@ -1998,22 +1998,22 @@ typedef struct _NV_ENC_MEONLY_PARAMS
  * Bitstream buffer lock parameters.
  */
 typedef struct _NV_ENC_LOCK_BITSTREAM
-{ 
+{
     uint32_t                version;                     /**< [in]: Struct version. Must be set to ::NV_ENC_LOCK_BITSTREAM_VER. */
-    uint32_t                doNotWait         :1;        /**< [in]: If this flag is set, the NvEncodeAPI interface will return buffer pointer even if operation is not completed. If not set, the call will block until operation completes. */
-    uint32_t                ltrFrame          :1;        /**< [out]: Flag indicating this frame is marked as LTR frame */
-    uint32_t                getRCStats        :1;        /**< [in]: If this flag is set then lockBitstream call will add additional intra-inter MB count and average MVX, MVY */
-    uint32_t                reservedBitFields :29;       /**< [in]: Reserved bit fields and must be set to 0 */
-    void*                   outputBitstream;             /**< [in]: Pointer to the bitstream buffer being locked. */
-    uint32_t*               sliceOffsets;                /**< [in, out]: Array which receives the slice offsets. This is not supported if NV_ENC_CONFIG_H264::sliceMode is 1 on Kepler GPUs. Array size must be equal to size of frame in MBs. */
-    uint32_t                frameIdx;                    /**< [out]: Frame no. for which the bitstream is being retrieved. */ 
+    uint32_t                doNotWait         : 1;       /**< [in]: If this flag is set, the NvEncodeAPI interface will return buffer pointer even if operation is not completed. If not set, the call will block until operation completes. */
+    uint32_t                ltrFrame          : 1;       /**< [out]: Flag indicating this frame is marked as LTR frame */
+    uint32_t                getRCStats        : 1;       /**< [in]: If this flag is set then lockBitstream call will add additional intra-inter MB count and average MVX, MVY */
+    uint32_t                reservedBitFields : 29;      /**< [in]: Reserved bit fields and must be set to 0 */
+    void                   *outputBitstream;             /**< [in]: Pointer to the bitstream buffer being locked. */
+    uint32_t               *sliceOffsets;                /**< [in, out]: Array which receives the slice offsets. This is not supported if NV_ENC_CONFIG_H264::sliceMode is 1 on Kepler GPUs. Array size must be equal to size of frame in MBs. */
+    uint32_t                frameIdx;                    /**< [out]: Frame no. for which the bitstream is being retrieved. */
     uint32_t                hwEncodeStatus;              /**< [out]: The NvEncodeAPI interface status for the locked picture. */
     uint32_t                numSlices;                   /**< [out]: Number of slices in the encoded picture. Will be reported only if NV_ENC_INITIALIZE_PARAMS::reportSliceOffsets set to 1. */
-    uint32_t                bitstreamSizeInBytes;        /**< [out]: Actual number of bytes generated and copied to the memory pointed by bitstreamBufferPtr. 
+    uint32_t                bitstreamSizeInBytes;        /**< [out]: Actual number of bytes generated and copied to the memory pointed by bitstreamBufferPtr.
                                                                      When HEVC alpha layer encoding is enabled, this field reports the total encoded size in bytes i.e it is the encoded size of the base plus the alpha layer. */
     uint64_t                outputTimeStamp;             /**< [out]: Presentation timestamp associated with the encoded output. */
     uint64_t                outputDuration;              /**< [out]: Presentation duration associates with the encoded output. */
-    void*                   bitstreamBufferPtr;          /**< [out]: Pointer to the generated output bitstream. 
+    void                   *bitstreamBufferPtr;          /**< [out]: Pointer to the generated output bitstream.
                                                                      For MEOnly mode _NV_ENC_LOCK_BITSTREAM::bitstreamBufferPtr should be typecast to
                                                                      NV_ENC_H264_MV_DATA/NV_ENC_HEVC_MV_DATA pointer respectively for H264/HEVC  */
     NV_ENC_PIC_TYPE         pictureType;                 /**< [out]: Picture type of the encoded picture. */
@@ -2028,10 +2028,10 @@ typedef struct _NV_ENC_LOCK_BITSTREAM
     uint32_t                interMBCount;                /**< [out]: For H264, Number of Inter MBs in the encoded frame, includes skip MBs. For HEVC, Number of Inter CTBs in the encoded frame. Supported only if _NV_ENC_LOCK_BITSTREAM::getRCStats set to 1. */
     int32_t                 averageMVX;                  /**< [out]: Average Motion Vector in X direction for the encoded frame. Supported only if _NV_ENC_LOCK_BITSTREAM::getRCStats set to 1. */
     int32_t                 averageMVY;                  /**< [out]: Average Motion Vector in y direction for the encoded frame. Supported only if _NV_ENC_LOCK_BITSTREAM::getRCStats set to 1. */
-    uint32_t                alphaLayerSizeInBytes;       /**< [out]: Number of bytes generated for the alpha layer in the encoded output. Applicable only when HEVC with alpha encoding is enabled. */ 
+    uint32_t                alphaLayerSizeInBytes;       /**< [out]: Number of bytes generated for the alpha layer in the encoded output. Applicable only when HEVC with alpha encoding is enabled. */
 
     uint32_t                reserved1[218];              /**< [in]: Reserved and must be set to 0 */
-    void*                   reserved2[64];               /**< [in]: Reserved and must be set to NULL */
+    void                   *reserved2[64];               /**< [in]: Reserved and must be set to NULL */
 } NV_ENC_LOCK_BITSTREAM;
 
 /** Macro for constructing the version field of ::_NV_ENC_LOCK_BITSTREAM */
@@ -2045,13 +2045,13 @@ typedef struct _NV_ENC_LOCK_BITSTREAM
 typedef struct _NV_ENC_LOCK_INPUT_BUFFER
 {
     uint32_t                  version;                   /**< [in]:  Struct version. Must be set to ::NV_ENC_LOCK_INPUT_BUFFER_VER. */
-    uint32_t                  doNotWait         :1;      /**< [in]:  Set to 1 to make ::NvEncLockInputBuffer() a unblocking call. If the encoding is not completed, driver will return ::NV_ENC_ERR_ENCODER_BUSY error code. */
-    uint32_t                  reservedBitFields :31;     /**< [in]:  Reserved bitfields and must be set to 0 */
+    uint32_t                  doNotWait         : 1;     /**< [in]:  Set to 1 to make ::NvEncLockInputBuffer() a unblocking call. If the encoding is not completed, driver will return ::NV_ENC_ERR_ENCODER_BUSY error code. */
+    uint32_t                  reservedBitFields : 31;    /**< [in]:  Reserved bitfields and must be set to 0 */
     NV_ENC_INPUT_PTR          inputBuffer;               /**< [in]:  Pointer to the input buffer to be locked, client should pass the pointer obtained from ::NvEncCreateInputBuffer() or ::NvEncMapInputResource API. */
-    void*                     bufferDataPtr;             /**< [out]: Pointed to the locked input buffer data. Client can only access input buffer using the \p bufferDataPtr. */
+    void                     *bufferDataPtr;             /**< [out]: Pointed to the locked input buffer data. Client can only access input buffer using the \p bufferDataPtr. */
     uint32_t                  pitch;                     /**< [out]: Pitch of the locked input buffer. */
     uint32_t                  reserved1[251];            /**< [in]:  Reserved and must be set to 0  */
-    void*                     reserved2[64];             /**< [in]:  Reserved and must be set to NULL  */
+    void                     *reserved2[64];             /**< [in]:  Reserved and must be set to NULL  */
 } NV_ENC_LOCK_INPUT_BUFFER;
 
 /** Macro for constructing the version field of ::_NV_ENC_LOCK_INPUT_BUFFER */
@@ -2066,12 +2066,12 @@ typedef struct _NV_ENC_MAP_INPUT_RESOURCE
 {
     uint32_t                   version;                   /**< [in]:  Struct version. Must be set to ::NV_ENC_MAP_INPUT_RESOURCE_VER. */
     uint32_t                   subResourceIndex;          /**< [in]:  Deprecated. Do not use. */
-    void*                      inputResource;             /**< [in]:  Deprecated. Do not use. */
+    void                      *inputResource;             /**< [in]:  Deprecated. Do not use. */
     NV_ENC_REGISTERED_PTR      registeredResource;        /**< [in]:  The Registered resource handle obtained by calling NvEncRegisterInputResource. */
     NV_ENC_INPUT_PTR           mappedResource;            /**< [out]: Mapped pointer corresponding to the registeredResource. This pointer must be used in NV_ENC_PIC_PARAMS::inputBuffer parameter in ::NvEncEncodePicture() API. */
     NV_ENC_BUFFER_FORMAT       mappedBufferFmt;           /**< [out]: Buffer format of the outputResource. This buffer format must be used in NV_ENC_PIC_PARAMS::bufferFmt if client using the above mapped resource pointer. */
     uint32_t                   reserved1[251];            /**< [in]:  Reserved and must be set to 0. */
-    void*                      reserved2[63];             /**< [in]:  Reserved and must be set to NULL */
+    void                      *reserved2[63];             /**< [in]:  Reserved and must be set to NULL */
 } NV_ENC_MAP_INPUT_RESOURCE;
 
 /** Macro for constructing the version field of ::_NV_ENC_MAP_INPUT_RESOURCE */
@@ -2093,7 +2093,7 @@ typedef struct _NV_ENC_INPUT_RESOURCE_OPENGL_TEX
   */
 typedef struct _NV_ENC_FENCE_POINT_D3D12
 {
-    void*                   pFence;                    /**< [in]: Pointer to ID3D12Fence. This fence object is used for synchronization. */
+    void                   *pFence;                    /**< [in]: Pointer to ID3D12Fence. This fence object is used for synchronization. */
     uint64_t                value;                     /**< [in]: Fence value to reach or exceed before the GPU operation or
                                                                   fence value to set the fence to, after the GPU operation. */
 } NV_ENC_FENCE_POINT_D3D12;
@@ -2107,10 +2107,10 @@ typedef struct _NV_ENC_INPUT_RESOURCE_D3D12
 {
     NV_ENC_REGISTERED_PTR       pInputBuffer;          /**< [in]: Specifies the input surface pointer. Client must use a pointer obtained from NvEncRegisterResource() in NV_ENC_REGISTER_RESOURCE::registeredResource
                                                                   when registering input surface. */
-    NV_ENC_FENCE_POINT_D3D12    inputFencePoint;       /**< [in]: Specifies the input fence and corresponding fence value to do GPU wait. 
+    NV_ENC_FENCE_POINT_D3D12    inputFencePoint;       /**< [in]: Specifies the input fence and corresponding fence value to do GPU wait.
                                                                   This fence will be used to do GPU wait until the specified fence reaches or exceeds the specified value. */
     uint32_t                    reserved1[16];         /**< [in]: Reserved and must be set to 0. */
-    void*                       reserved2[16];         /**< [in]: Reserved and must be set to NULL. */
+    void                       *reserved2[16];         /**< [in]: Reserved and must be set to NULL. */
 } NV_ENC_INPUT_RESOURCE_D3D12;
 
 /**
@@ -2124,7 +2124,7 @@ typedef struct _NV_ENC_OUTPUT_RESOURCE_D3D12
                                                                   when registering output bitstream buffer */
     NV_ENC_FENCE_POINT_D3D12   outputFencePoint;       /**< [in]: Specifies the output fence and corresponding fence value to set after GPU operation is finished.*/
     uint32_t                   reserved1[16];          /**< [in]: Reserved and must be set to 0. */
-    void*                      reserved2[16];          /**< [in]: Reserved and must be set to NULL. */
+    void                      *reserved2[16];          /**< [in]: Reserved and must be set to NULL. */
 } NV_ENC_OUTPUT_RESOURCE_D3D12;
 
 /**
@@ -2154,19 +2154,19 @@ typedef struct _NV_ENC_REGISTER_RESOURCE
                                                                              texture width multiplied by the number of components in the texture
                                                                              format. */
     uint32_t                    subResourceIndex;               /**< [in]: Subresource Index of the DirectX resource to be registered. Should be set to 0 for other interfaces. */
-    void*                       resourceToRegister;             /**< [in]: Handle to the resource that is being registered. */
+    void                       *resourceToRegister;             /**< [in]: Handle to the resource that is being registered. */
     NV_ENC_REGISTERED_PTR       registeredResource;             /**< [out]: Registered resource handle. This should be used in future interactions with the Nvidia Video Encoder Interface. */
     NV_ENC_BUFFER_FORMAT        bufferFormat;                   /**< [in]: Buffer format of resource to be registered. */
     NV_ENC_BUFFER_USAGE         bufferUsage;                    /**< [in]: Usage of resource to be registered. */
-    NV_ENC_FENCE_POINT_D3D12*   pInputFencePoint;               /**< [in]: Specifies the pointer to input fence and corresponding fence value to do GPU wait.
+    NV_ENC_FENCE_POINT_D3D12   *pInputFencePoint;               /**< [in]: Specifies the pointer to input fence and corresponding fence value to do GPU wait.
                                                                            To be used only when NV_ENC_REGISTER_RESOURCE::resourceToRegister represents D3D12 surface and
                                                                            NV_ENC_BUFFER_USAGE::bufferUsage is NV_ENC_INPUT_IMAGE.
                                                                            This fence will be used to do GPU wait until the specified fence reaches or exceeds the specified value. */
-    NV_ENC_FENCE_POINT_D3D12*   pOutputFencePoint;              /**< [in]: Specifies the pointer to output fence and corresponding fence value to set after GPU operation is finished.
+    NV_ENC_FENCE_POINT_D3D12   *pOutputFencePoint;              /**< [in]: Specifies the pointer to output fence and corresponding fence value to set after GPU operation is finished.
                                                                            To be used only when NV_ENC_REGISTER_RESOURCE::resourceToRegister represents D3D12 surface and
                                                                            NV_ENC_BUFFER_USAGE::bufferUsage is NV_ENC_INPUT_IMAGE. */
     uint32_t                    reserved1[247];                 /**< [in]: Reserved and must be set to 0. */
-    void*                       reserved2[60];                  /**< [in]: Reserved and must be set to NULL. */
+    void                       *reserved2[60];                  /**< [in]: Reserved and must be set to NULL. */
 } NV_ENC_REGISTER_RESOURCE;
 
 /** Macro for constructing the version field of ::_NV_ENC_REGISTER_RESOURCE */
@@ -2187,15 +2187,15 @@ typedef struct _NV_ENC_STAT
     uint32_t            sliceOffsets[16];                /**< [out]: Offsets of each slice */
     uint32_t            picIdx;                          /**< [out]: Picture number */
     uint32_t            frameAvgQP;                      /**< [out]: Average QP of the frame. */
-    uint32_t            ltrFrame          :1;            /**< [out]: Flag indicating this frame is marked as LTR frame */
-    uint32_t            reservedBitFields :31;           /**< [in]:  Reserved bit fields and must be set to 0 */
+    uint32_t            ltrFrame          : 1;           /**< [out]: Flag indicating this frame is marked as LTR frame */
+    uint32_t            reservedBitFields : 31;          /**< [in]:  Reserved bit fields and must be set to 0 */
     uint32_t            ltrFrameIdx;                     /**< [out]: Frame index associated with this LTR frame. */
     uint32_t            intraMBCount;                    /**< [out]: For H264, Number of Intra MBs in the encoded frame. For HEVC, Number of Intra CTBs in the encoded frame. */
     uint32_t            interMBCount;                    /**< [out]: For H264, Number of Inter MBs in the encoded frame, includes skip MBs. For HEVC, Number of Inter CTBs in the encoded frame. */
     int32_t             averageMVX;                      /**< [out]: Average Motion Vector in X direction for the encoded frame. */
     int32_t             averageMVY;                      /**< [out]: Average Motion Vector in y direction for the encoded frame. */
     uint32_t            reserved1[226];                  /**< [in]:  Reserved and must be set to 0 */
-    void*               reserved2[64];                   /**< [in]:  Reserved and must be set to NULL */
+    void               *reserved2[64];                   /**< [in]:  Reserved and must be set to NULL */
 } NV_ENC_STAT;
 
 /** Macro for constructing the version field of ::_NV_ENC_STAT */
@@ -2212,11 +2212,11 @@ typedef struct _NV_ENC_SEQUENCE_PARAM_PAYLOAD
     uint32_t            inBufferSize;                    /**< [in]:  Specifies the size of the spsppsBuffer provided by the client */
     uint32_t            spsId;                           /**< [in]:  Specifies the SPS id to be used in sequence header. Default value is 0.  */
     uint32_t            ppsId;                           /**< [in]:  Specifies the PPS id to be used in picture header. Default value is 0.  */
-    void*               spsppsBuffer;                    /**< [in]:  Specifies bitstream header pointer of size NV_ENC_SEQUENCE_PARAM_PAYLOAD::inBufferSize. 
+    void               *spsppsBuffer;                    /**< [in]:  Specifies bitstream header pointer of size NV_ENC_SEQUENCE_PARAM_PAYLOAD::inBufferSize.
                                                                      It is the client's responsibility to manage this memory. */
-    uint32_t*           outSPSPPSPayloadSize;            /**< [out]: Size of the sequence and picture header in bytes. */
+    uint32_t           *outSPSPPSPayloadSize;            /**< [out]: Size of the sequence and picture header in bytes. */
     uint32_t            reserved [250];                  /**< [in]:  Reserved and must be set to 0 */
-    void*               reserved2[64];                   /**< [in]:  Reserved and must be set to NULL */
+    void               *reserved2[64];                   /**< [in]:  Reserved and must be set to NULL */
 } NV_ENC_SEQUENCE_PARAM_PAYLOAD;
 
 /** Macro for constructing the version field of ::_NV_ENC_SEQUENCE_PARAM_PAYLOAD */
@@ -2230,9 +2230,9 @@ typedef struct _NV_ENC_EVENT_PARAMS
 {
     uint32_t            version;                          /**< [in]: Struct version. Must be set to ::NV_ENC_EVENT_PARAMS_VER. */
     uint32_t            reserved;                         /**< [in]: Reserved and must be set to 0 */
-    void*               completionEvent;                  /**< [in]: Handle to event to be registered/unregistered with the NvEncodeAPI interface. */
+    void               *completionEvent;                  /**< [in]: Handle to event to be registered/unregistered with the NvEncodeAPI interface. */
     uint32_t            reserved1[253];                   /**< [in]: Reserved and must be set to 0    */
-    void*               reserved2[64];                    /**< [in]: Reserved and must be set to NULL */
+    void               *reserved2[64];                    /**< [in]: Reserved and must be set to NULL */
 } NV_ENC_EVENT_PARAMS;
 
 /** Macro for constructing the version field of ::_NV_ENC_EVENT_PARAMS */
@@ -2245,11 +2245,11 @@ typedef struct _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS
 {
     uint32_t            version;                          /**< [in]: Struct version. Must be set to ::NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS_VER. */
     NV_ENC_DEVICE_TYPE  deviceType;                       /**< [in]: Specified the device Type */
-    void*               device;                           /**< [in]: Pointer to client device. */
-    void*               reserved;                         /**< [in]: Reserved and must be set to 0. */
+    void               *device;                           /**< [in]: Pointer to client device. */
+    void               *reserved;                         /**< [in]: Reserved and must be set to 0. */
     uint32_t            apiVersion;                       /**< [in]: API version. Should be set to NVENCAPI_VERSION. */
     uint32_t            reserved1[253];                   /**< [in]: Reserved and must be set to 0    */
-    void*               reserved2[64];                    /**< [in]: Reserved and must be set to NULL */
+    void               *reserved2[64];                    /**< [in]: Reserved and must be set to NULL */
 } NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS;
 /** Macro for constructing the version field of ::_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS */
 #define NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS_VER NVENCAPI_STRUCT_VERSION(1)
@@ -2265,14 +2265,14 @@ typedef struct _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS
 // NvEncOpenEncodeSession
 /**
  * \brief Opens an encoding session.
- * 
+ *
  * Deprecated.
  *
  * \return
  * ::NV_ENC_ERR_INVALID_CALL\n
  *
  */
-NVENCSTATUS NVENCAPI NvEncOpenEncodeSession                     (void* device, uint32_t deviceType, void** encoder);
+NVENCSTATUS NVENCAPI NvEncOpenEncodeSession                     (void *device, uint32_t deviceType, void **encoder);
 
 // NvEncGetEncodeGuidCount
 /**
@@ -2280,10 +2280,10 @@ NVENCSTATUS NVENCAPI NvEncOpenEncodeSession                     (void* device, u
  *
  * The function returns the number of codec GUIDs supported by the NvEncodeAPI
  * interface.
- *  
- * \param [in] encoder  
+ *
+ * \param [in] encoder
  *   Pointer to the NvEncodeAPI interface.
- * \param [out] encodeGUIDCount 
+ * \param [out] encodeGUIDCount
  *   Number of supported encode GUIDs.
  *
  * \return
@@ -2297,7 +2297,7 @@ NVENCSTATUS NVENCAPI NvEncOpenEncodeSession                     (void* device, u
  * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncGetEncodeGUIDCount                    (void* encoder, uint32_t* encodeGUIDCount);
+NVENCSTATUS NVENCAPI NvEncGetEncodeGUIDCount                    (void *encoder, uint32_t *encodeGUIDCount);
 
 
 // NvEncGetEncodeGUIDs
@@ -2332,22 +2332,22 @@ NVENCSTATUS NVENCAPI NvEncGetEncodeGUIDCount                    (void* encoder,
  * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncGetEncodeGUIDs                        (void* encoder, GUID* GUIDs, uint32_t guidArraySize, uint32_t* GUIDCount);
+NVENCSTATUS NVENCAPI NvEncGetEncodeGUIDs                        (void *encoder, GUID *GUIDs, uint32_t guidArraySize, uint32_t *GUIDCount);
 
 
 // NvEncGetEncodeProfileGuidCount
 /**
  * \brief Retrieves the number of supported profile GUIDs.
  *
- * The function returns the number of profile GUIDs supported for a given codec. 
- * The client must first enumerate the codec GUIDs supported by the NvEncodeAPI 
+ * The function returns the number of profile GUIDs supported for a given codec.
+ * The client must first enumerate the codec GUIDs supported by the NvEncodeAPI
  * interface. After determining the codec GUID, it can query the NvEncodeAPI
  * interface to determine the number of profile GUIDs supported for a particular
  * codec GUID.
  *
- * \param [in] encoder  
+ * \param [in] encoder
  *   Pointer to the NvEncodeAPI interface.
- * \param [in] encodeGUID 
+ * \param [in] encodeGUID
  *   The codec GUID for which the profile GUIDs are being enumerated.
  * \param [out] encodeProfileGUIDCount
  *   Number of encode profiles supported for the given encodeGUID.
@@ -2363,7 +2363,7 @@ NVENCSTATUS NVENCAPI NvEncGetEncodeGUIDs                        (void* encoder,
  * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncGetEncodeProfileGUIDCount                    (void* encoder, GUID encodeGUID, uint32_t* encodeProfileGUIDCount);
+NVENCSTATUS NVENCAPI NvEncGetEncodeProfileGUIDCount                    (void *encoder, GUID encodeGUID, uint32_t *encodeProfileGUIDCount);
 
 
 // NvEncGetEncodeProfileGUIDs
@@ -2372,7 +2372,7 @@ NVENCSTATUS NVENCAPI NvEncGetEncodeProfileGUIDCount                    (void* en
  *
  * The function returns an array of supported profile GUIDs for a particular
  * codec GUID. The client must allocate an array where the NvEncodeAPI interface
- * can populate the profile GUIDs. The client can determine the array size using 
+ * can populate the profile GUIDs. The client can determine the array size using
  * ::NvEncGetEncodeProfileGUIDCount() API. The client must also validiate that the
  * NvEncodeAPI interface supports the GUID the client wants to pass as \p encodeGUID
  * parameter.
@@ -2382,7 +2382,7 @@ NVENCSTATUS NVENCAPI NvEncGetEncodeProfileGUIDCount                    (void* en
  * \param [in] encodeGUID
  *   The encode GUID whose profile GUIDs are being enumerated.
  * \param [in] guidArraySize
- *   Number of GUIDs to be retrieved. Should be set to the number retrieved using 
+ *   Number of GUIDs to be retrieved. Should be set to the number retrieved using
  *   ::NvEncGetEncodeProfileGUIDCount.
  * \param [out] profileGUIDs
  *   Array of supported Encode Profile GUIDs
@@ -2400,7 +2400,7 @@ NVENCSTATUS NVENCAPI NvEncGetEncodeProfileGUIDCount                    (void* en
  * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncGetEncodeProfileGUIDs                               (void* encoder, GUID encodeGUID, GUID* profileGUIDs, uint32_t guidArraySize, uint32_t* GUIDCount);
+NVENCSTATUS NVENCAPI NvEncGetEncodeProfileGUIDs                               (void *encoder, GUID encodeGUID, GUID *profileGUIDs, uint32_t guidArraySize, uint32_t *GUIDCount);
 
 // NvEncGetInputFormatCount
 /**
@@ -2413,7 +2413,7 @@ NVENCSTATUS NVENCAPI NvEncGetEncodeProfileGUIDs                               (v
  * \param [in] encoder
  *   Pointer to the NvEncodeAPI interface.
  * \param [in] encodeGUID
- *   Encode GUID, corresponding to which the number of supported input formats 
+ *   Encode GUID, corresponding to which the number of supported input formats
  *   is to be retrieved.
  * \param [out] inputFmtCount
  *   Number of input formats supported for specified Encode GUID.
@@ -2428,20 +2428,20 @@ NVENCSTATUS NVENCAPI NvEncGetEncodeProfileGUIDs                               (v
  * ::NV_ENC_ERR_INVALID_PARAM \n
  * ::NV_ENC_ERR_GENERIC \n
  */
-NVENCSTATUS NVENCAPI NvEncGetInputFormatCount                   (void* encoder, GUID encodeGUID, uint32_t* inputFmtCount);
+NVENCSTATUS NVENCAPI NvEncGetInputFormatCount                   (void *encoder, GUID encodeGUID, uint32_t *inputFmtCount);
 
 
 // NvEncGetInputFormats
 /**
  * \brief Retrieves an array of supported Input formats
  *
- * Returns an array of supported input formats  The client must use the input 
+ * Returns an array of supported input formats  The client must use the input
  * format to create input surface using ::NvEncCreateInputBuffer() API.
- * 
- * \param [in] encoder 
+ *
+ * \param [in] encoder
  *   Pointer to the NvEncodeAPI interface.
  * \param [in] encodeGUID
- *   Encode GUID, corresponding to which the number of supported input formats 
+ *   Encode GUID, corresponding to which the number of supported input formats
  *   is to be retrieved.
  *\param [in] inputFmtArraySize
  *   Size input format count array passed in \p inputFmts.
@@ -2462,16 +2462,16 @@ NVENCSTATUS NVENCAPI NvEncGetInputFormatCount                   (void* encoder,
  * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncGetInputFormats                       (void* encoder, GUID encodeGUID, NV_ENC_BUFFER_FORMAT* inputFmts, uint32_t inputFmtArraySize, uint32_t* inputFmtCount);
+NVENCSTATUS NVENCAPI NvEncGetInputFormats                       (void *encoder, GUID encodeGUID, NV_ENC_BUFFER_FORMAT *inputFmts, uint32_t inputFmtArraySize, uint32_t *inputFmtCount);
 
 
 // NvEncGetEncodeCaps
 /**
  * \brief Retrieves the capability value for a specified encoder attribute.
  *
- * The function returns the capability value for a given encoder attribute. The 
- * client must validate the encodeGUID using ::NvEncGetEncodeGUIDs() API before 
- * calling this function. The encoder attribute being queried are enumerated in 
+ * The function returns the capability value for a given encoder attribute. The
+ * client must validate the encodeGUID using ::NvEncGetEncodeGUIDs() API before
+ * calling this function. The encoder attribute being queried are enumerated in
  * ::NV_ENC_CAPS_PARAM enum.
  *
  * \param [in] encoder
@@ -2479,7 +2479,7 @@ NVENCSTATUS NVENCAPI NvEncGetInputFormats                       (void* encoder,
  * \param [in] encodeGUID
  *   Encode GUID, corresponding to which the capability attribute is to be retrieved.
  * \param [in] capsParam
- *   Used to specify attribute being queried. Refer ::NV_ENC_CAPS_PARAM for  more 
+ *   Used to specify attribute being queried. Refer ::NV_ENC_CAPS_PARAM for  more
  * details.
  * \param [out] capsVal
  *   The value corresponding to the capability attribute being queried.
@@ -2494,21 +2494,21 @@ NVENCSTATUS NVENCAPI NvEncGetInputFormats                       (void* encoder,
  * ::NV_ENC_ERR_INVALID_PARAM \n
  * ::NV_ENC_ERR_GENERIC \n
  */
-NVENCSTATUS NVENCAPI NvEncGetEncodeCaps                     (void* encoder, GUID encodeGUID, NV_ENC_CAPS_PARAM* capsParam, int* capsVal);
+NVENCSTATUS NVENCAPI NvEncGetEncodeCaps                     (void *encoder, GUID encodeGUID, NV_ENC_CAPS_PARAM *capsParam, int *capsVal);
 
 
 // NvEncGetEncodePresetCount
 /**
  * \brief Retrieves the number of supported preset GUIDs.
  *
- * The function returns the number of preset GUIDs available for a given codec. 
- * The client must validate the codec GUID using ::NvEncGetEncodeGUIDs() API 
+ * The function returns the number of preset GUIDs available for a given codec.
+ * The client must validate the codec GUID using ::NvEncGetEncodeGUIDs() API
  * before calling this function.
  *
  * \param [in] encoder
  *   Pointer to the NvEncodeAPI interface.
  * \param [in] encodeGUID
- *   Encode GUID, corresponding to which the number of supported presets is to 
+ *   Encode GUID, corresponding to which the number of supported presets is to
  *   be retrieved.
  * \param [out] encodePresetGUIDCount
  *   Receives the number of supported preset GUIDs.
@@ -2524,26 +2524,26 @@ NVENCSTATUS NVENCAPI NvEncGetEncodeCaps                     (void* encoder, GUID
  * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncGetEncodePresetCount              (void* encoder, GUID encodeGUID, uint32_t* encodePresetGUIDCount);
+NVENCSTATUS NVENCAPI NvEncGetEncodePresetCount              (void *encoder, GUID encodeGUID, uint32_t *encodePresetGUIDCount);
 
 
 // NvEncGetEncodePresetGUIDs
 /**
  * \brief Receives an array of supported encoder preset GUIDs.
  *
- * The function returns an array of encode preset GUIDs available for a given codec. 
+ * The function returns an array of encode preset GUIDs available for a given codec.
  * The client can directly use one of the preset GUIDs based upon the use case
- * or target device. The preset GUID chosen can be directly used in 
- * NV_ENC_INITIALIZE_PARAMS::presetGUID parameter to ::NvEncEncodePicture() API. 
- * Alternately client can  also use the preset GUID to retrieve the encoding config 
+ * or target device. The preset GUID chosen can be directly used in
+ * NV_ENC_INITIALIZE_PARAMS::presetGUID parameter to ::NvEncEncodePicture() API.
+ * Alternately client can  also use the preset GUID to retrieve the encoding config
  * parameters being used by NvEncodeAPI interface for that given preset, using
  * ::NvEncGetEncodePresetConfig() API. It can then modify preset config parameters
- * as per its use case and send it to NvEncodeAPI interface as part of 
+ * as per its use case and send it to NvEncodeAPI interface as part of
  * NV_ENC_INITIALIZE_PARAMS::encodeConfig parameter for NvEncInitializeEncoder()
  * API.
  *
  *
- * \param [in] encoder 
+ * \param [in] encoder
  *   Pointer to the NvEncodeAPI interface.
  * \param [in] encodeGUID
  *   Encode GUID, corresponding to which the list of supported presets is to be
@@ -2551,10 +2551,10 @@ NVENCSTATUS NVENCAPI NvEncGetEncodePresetCount              (void* encoder, GUID
  * \param [in] guidArraySize
  *   Size of array of preset GUIDs passed in \p preset GUIDs
  * \param [out] presetGUIDs
- *   Array of supported Encode preset GUIDs from the NvEncodeAPI interface 
+ *   Array of supported Encode preset GUIDs from the NvEncodeAPI interface
  *   to client.
  * \param [out] encodePresetGUIDCount
- *   Receives the number of preset GUIDs returned by the NvEncodeAPI 
+ *   Receives the number of preset GUIDs returned by the NvEncodeAPI
  *   interface.
  *
  * \return
@@ -2568,28 +2568,28 @@ NVENCSTATUS NVENCAPI NvEncGetEncodePresetCount              (void* encoder, GUID
  * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncGetEncodePresetGUIDs                  (void* encoder, GUID encodeGUID, GUID* presetGUIDs, uint32_t guidArraySize, uint32_t* encodePresetGUIDCount);
+NVENCSTATUS NVENCAPI NvEncGetEncodePresetGUIDs                  (void *encoder, GUID encodeGUID, GUID *presetGUIDs, uint32_t guidArraySize, uint32_t *encodePresetGUIDCount);
 
 
 // NvEncGetEncodePresetConfig
 /**
  * \brief Returns a preset config structure supported for given preset GUID.
  *
- * The function returns a preset config structure for a given preset GUID. Before  
- * using this function the client must enumerate the preset GUIDs available for 
+ * The function returns a preset config structure for a given preset GUID. Before
+ * using this function the client must enumerate the preset GUIDs available for
  * a given codec. The preset config structure can be modified by the client depending
- * upon its use case and can be then used to initialize the encoder using 
- * ::NvEncInitializeEncoder() API. The client can use this function only if it 
- * wants to modify the NvEncodeAPI preset configuration, otherwise it can 
+ * upon its use case and can be then used to initialize the encoder using
+ * ::NvEncInitializeEncoder() API. The client can use this function only if it
+ * wants to modify the NvEncodeAPI preset configuration, otherwise it can
  * directly use the preset GUID.
- * 
+ *
  * \param [in] encoder
- *   Pointer to the NvEncodeAPI interface. 
+ *   Pointer to the NvEncodeAPI interface.
  * \param [in] encodeGUID
  *   Encode GUID, corresponding to which the list of supported presets is to be
  *   retrieved.
  * \param [in] presetGUID
- *   Preset GUID, corresponding to which the Encoding configurations is to be 
+ *   Preset GUID, corresponding to which the Encoding configurations is to be
  *   retrieved.
  * \param [out] presetConfig
  *   The requested Preset Encoder Attribute set. Refer ::_NV_ENC_CONFIG for
@@ -2607,31 +2607,31 @@ NVENCSTATUS NVENCAPI NvEncGetEncodePresetGUIDs                  (void* encoder,
  * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncGetEncodePresetConfig               (void* encoder, GUID encodeGUID, GUID  presetGUID, NV_ENC_PRESET_CONFIG* presetConfig);
+NVENCSTATUS NVENCAPI NvEncGetEncodePresetConfig               (void *encoder, GUID encodeGUID, GUID  presetGUID, NV_ENC_PRESET_CONFIG *presetConfig);
 
 // NvEncGetEncodePresetConfigEx
 /**
  * \brief Returns a preset config structure supported for given preset GUID.
  *
- * The function returns a preset config structure for a given preset GUID and tuning info. 
+ * The function returns a preset config structure for a given preset GUID and tuning info.
  * NvEncGetEncodePresetConfigEx() API is not applicable to H264 and HEVC meonly mode.
- * Before using this function the client must enumerate the preset GUIDs available for 
+ * Before using this function the client must enumerate the preset GUIDs available for
  * a given codec. The preset config structure can be modified by the client depending
- * upon its use case and can be then used to initialize the encoder using 
- * ::NvEncInitializeEncoder() API. The client can use this function only if it 
- * wants to modify the NvEncodeAPI preset configuration, otherwise it can 
+ * upon its use case and can be then used to initialize the encoder using
+ * ::NvEncInitializeEncoder() API. The client can use this function only if it
+ * wants to modify the NvEncodeAPI preset configuration, otherwise it can
  * directly use the preset GUID.
- * 
+ *
  * \param [in] encoder
- *   Pointer to the NvEncodeAPI interface. 
+ *   Pointer to the NvEncodeAPI interface.
  * \param [in] encodeGUID
  *   Encode GUID, corresponding to which the list of supported presets is to be
  *   retrieved.
  * \param [in] presetGUID
- *   Preset GUID, corresponding to which the Encoding configurations is to be 
+ *   Preset GUID, corresponding to which the Encoding configurations is to be
  *   retrieved.
  * \param [in] tuningInfo
- *   tuning info, corresponding to which the Encoding configurations is to be 
+ *   tuning info, corresponding to which the Encoding configurations is to be
  *   retrieved.
  * \param [out] presetConfig
  *   The requested Preset Encoder Attribute set. Refer ::_NV_ENC_CONFIG for
@@ -2649,7 +2649,7 @@ NVENCSTATUS NVENCAPI NvEncGetEncodePresetConfig               (void* encoder, GU
  * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncGetEncodePresetConfigEx               (void* encoder, GUID encodeGUID, GUID  presetGUID, NV_ENC_TUNING_INFO tuningInfo, NV_ENC_PRESET_CONFIG* presetConfig);
+NVENCSTATUS NVENCAPI NvEncGetEncodePresetConfigEx               (void *encoder, GUID encodeGUID, GUID  presetGUID, NV_ENC_TUNING_INFO tuningInfo, NV_ENC_PRESET_CONFIG *presetConfig);
 
 // NvEncInitializeEncoder
 /**
@@ -2661,11 +2661,11 @@ NVENCSTATUS NVENCAPI NvEncGetEncodePresetConfigEx               (void* encoder,
  * - NV_ENC_INITIALIZE_PARAMS::encodeGUID
  * - NV_ENC_INITIALIZE_PARAMS::encodeWidth
  * - NV_ENC_INITIALIZE_PARAMS::encodeHeight
- * 
+ *
  * The client can pass a preset GUID directly to the NvEncodeAPI interface using
- * NV_ENC_INITIALIZE_PARAMS::presetGUID field. If the client doesn't pass 
+ * NV_ENC_INITIALIZE_PARAMS::presetGUID field. If the client doesn't pass
  * NV_ENC_INITIALIZE_PARAMS::encodeConfig structure, the codec specific parameters
- * will be selected based on the preset GUID. The preset GUID must have been 
+ * will be selected based on the preset GUID. The preset GUID must have been
  * validated by the client using ::NvEncGetEncodePresetGUIDs() API.
  * If the client passes a custom ::_NV_ENC_CONFIG structure through
  * NV_ENC_INITIALIZE_PARAMS::encodeConfig , it will override the codec specific parameters
@@ -2699,7 +2699,7 @@ NVENCSTATUS NVENCAPI NvEncGetEncodePresetConfigEx               (void* encoder,
  * The client working in synchronous mode can work in a single threaded or multi
  * threaded mode. The client need not allocate any event objects. The client can
  * only lock the bitstream data after NvEncodeAPI interface has returned
- * ::NV_ENC_SUCCESS from encode picture. The NvEncodeAPI interface can return 
+ * ::NV_ENC_SUCCESS from encode picture. The NvEncodeAPI interface can return
  * ::NV_ENC_ERR_NEED_MORE_INPUT error code from ::NvEncEncodePicture() API. The
  * client must not lock the output buffer in such case but should send the next
  * frame for encoding. The client must keep on calling ::NvEncEncodePicture() API
@@ -2710,16 +2710,16 @@ NVENCSTATUS NVENCAPI NvEncGetEncodePresetConfigEx               (void* encoder,
  *\par Picture type decision:
  * If the client is taking the picture type decision and it must disable the picture
  * type decision module in NvEncodeAPI by setting NV_ENC_INITIALIZE_PARAMS::enablePTD
- * to 0. In this case the client is  required to send the picture in encoding 
+ * to 0. In this case the client is  required to send the picture in encoding
  * order to NvEncodeAPI by doing the re-ordering for B frames. \n
- * If the client doesn't want to take the picture type decision it can enable 
- * picture type decision module in the NvEncodeAPI interface by setting 
- * NV_ENC_INITIALIZE_PARAMS::enablePTD to 1 and send the input pictures in display 
+ * If the client doesn't want to take the picture type decision it can enable
+ * picture type decision module in the NvEncodeAPI interface by setting
+ * NV_ENC_INITIALIZE_PARAMS::enablePTD to 1 and send the input pictures in display
  * order.
- * 
+ *
  * \param [in] encoder
  *   Pointer to the NvEncodeAPI interface.
- * \param [in] createEncodeParams 
+ * \param [in] createEncodeParams
  *   Refer ::_NV_ENC_INITIALIZE_PARAMS for details.
  *
  * \return
@@ -2734,7 +2734,7 @@ NVENCSTATUS NVENCAPI NvEncGetEncodePresetConfigEx               (void* encoder,
  * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncInitializeEncoder                     (void* encoder, NV_ENC_INITIALIZE_PARAMS* createEncodeParams);
+NVENCSTATUS NVENCAPI NvEncInitializeEncoder                     (void *encoder, NV_ENC_INITIALIZE_PARAMS *createEncodeParams);
 
 
 // NvEncCreateInputBuffer
@@ -2742,10 +2742,10 @@ NVENCSTATUS NVENCAPI NvEncInitializeEncoder                     (void* encoder,
  * \brief Allocates Input buffer.
  *
  * This function is used to allocate an input buffer. The client must enumerate
- * the input buffer format before allocating the input buffer resources. The 
- * NV_ENC_INPUT_PTR returned by the NvEncodeAPI interface in the 
+ * the input buffer format before allocating the input buffer resources. The
+ * NV_ENC_INPUT_PTR returned by the NvEncodeAPI interface in the
  * NV_ENC_CREATE_INPUT_BUFFER::inputBuffer field can be directly used in
- * ::NvEncEncodePicture() API. The number of input buffers to be allocated by the 
+ * ::NvEncEncodePicture() API. The number of input buffers to be allocated by the
  * client must be at least 4 more than the number of B frames being used for encoding.
  *
  * \param [in] encoder
@@ -2763,9 +2763,9 @@ NVENCSTATUS NVENCAPI NvEncInitializeEncoder                     (void* encoder,
  * ::NV_ENC_ERR_INVALID_PARAM \n
  * ::NV_ENC_ERR_INVALID_VERSION \n
  * ::NV_ENC_ERR_GENERIC \n
- * 
+ *
  */
-NVENCSTATUS NVENCAPI NvEncCreateInputBuffer                     (void* encoder, NV_ENC_CREATE_INPUT_BUFFER* createInputBufferParams);
+NVENCSTATUS NVENCAPI NvEncCreateInputBuffer                     (void *encoder, NV_ENC_CREATE_INPUT_BUFFER *createInputBufferParams);
 
 
 // NvEncDestroyInputBuffer
@@ -2779,7 +2779,7 @@ NVENCSTATUS NVENCAPI NvEncCreateInputBuffer                     (void* encoder,
  *
  * \param [in] encoder
  *   Pointer to the NvEncodeAPI interface.
- * \param [in] inputBuffer 
+ * \param [in] inputBuffer
  *   Pointer to the input buffer to be released.
  *
  * \return
@@ -2794,25 +2794,25 @@ NVENCSTATUS NVENCAPI NvEncCreateInputBuffer                     (void* encoder,
  * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncDestroyInputBuffer                    (void* encoder, NV_ENC_INPUT_PTR inputBuffer);
+NVENCSTATUS NVENCAPI NvEncDestroyInputBuffer                    (void *encoder, NV_ENC_INPUT_PTR inputBuffer);
 
 // NvEncSetIOCudaStreams
 /**
  * \brief Set input and output CUDA stream for specified encoder attribute.
  *
  * Encoding may involve CUDA pre-processing on the input and post-processing on encoded output.
- * This function is used to set input and output CUDA streams to pipeline the CUDA pre-processing 
- * and post-processing tasks. Clients should call this function before the call to 
- * NvEncUnlockInputBuffer(). If this function is not called, the default CUDA stream is used for 
- * input and output processing. After a successful call to this function, the streams specified 
- * in that call will replace the previously-used streams. 
+ * This function is used to set input and output CUDA streams to pipeline the CUDA pre-processing
+ * and post-processing tasks. Clients should call this function before the call to
+ * NvEncUnlockInputBuffer(). If this function is not called, the default CUDA stream is used for
+ * input and output processing. After a successful call to this function, the streams specified
+ * in that call will replace the previously-used streams.
  * This API is supported for NVCUVID interface only.
  *
- * \param [in] encoder 
+ * \param [in] encoder
  *   Pointer to the NvEncodeAPI interface.
  * \param [in] inputStream
  *   Pointer to CUstream which is used to process ::NV_ENC_PIC_PARAMS::inputFrame for encode.
- *   In case of ME-only mode, inputStream is used to process ::NV_ENC_MEONLY_PARAMS::inputBuffer and 
+ *   In case of ME-only mode, inputStream is used to process ::NV_ENC_MEONLY_PARAMS::inputBuffer and
  *   ::NV_ENC_MEONLY_PARAMS::referenceFrame
  * \param [in] outputStream
  *  Pointer to CUstream which is used to process ::NV_ENC_PIC_PARAMS::outputBuffer for encode.
@@ -2829,20 +2829,20 @@ NVENCSTATUS NVENCAPI NvEncDestroyInputBuffer                    (void* encoder,
  * ::NV_ENC_ERR_INVALID_VERSION \n
  * ::NV_ENC_ERR_GENERIC \n
  */
-NVENCSTATUS NVENCAPI NvEncSetIOCudaStreams                     (void* encoder, NV_ENC_CUSTREAM_PTR inputStream, NV_ENC_CUSTREAM_PTR outputStream);
+NVENCSTATUS NVENCAPI NvEncSetIOCudaStreams                     (void *encoder, NV_ENC_CUSTREAM_PTR inputStream, NV_ENC_CUSTREAM_PTR outputStream);
 
 
 // NvEncCreateBitstreamBuffer
 /**
- * \brief Allocates an output bitstream buffer 
+ * \brief Allocates an output bitstream buffer
  *
- * This function is used to allocate an output bitstream buffer and returns a 
- * NV_ENC_OUTPUT_PTR to bitstream  buffer to the client in the 
+ * This function is used to allocate an output bitstream buffer and returns a
+ * NV_ENC_OUTPUT_PTR to bitstream  buffer to the client in the
  * NV_ENC_CREATE_BITSTREAM_BUFFER::bitstreamBuffer field.
- * The client can only call this function after the encoder session has been 
- * initialized using ::NvEncInitializeEncoder() API. The minimum number of output 
+ * The client can only call this function after the encoder session has been
+ * initialized using ::NvEncInitializeEncoder() API. The minimum number of output
  * buffers allocated by the client must be at least 4 more than the number of B
- * B frames being used for encoding. The client can only access the output 
+ * B frames being used for encoding. The client can only access the output
  * bitstream data by locking the \p bitstreamBuffer using the ::NvEncLockBitstream()
  * function.
  *
@@ -2864,12 +2864,12 @@ NVENCSTATUS NVENCAPI NvEncSetIOCudaStreams                     (void* encoder, N
  * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncCreateBitstreamBuffer                 (void* encoder, NV_ENC_CREATE_BITSTREAM_BUFFER* createBitstreamBufferParams);
+NVENCSTATUS NVENCAPI NvEncCreateBitstreamBuffer                 (void *encoder, NV_ENC_CREATE_BITSTREAM_BUFFER *createBitstreamBufferParams);
 
 
 // NvEncDestroyBitstreamBuffer
 /**
- * \brief Release a bitstream buffer. 
+ * \brief Release a bitstream buffer.
  *
  * This function is used to release the output bitstream buffer allocated using
  * the ::NvEncCreateBitstreamBuffer() function. The client must release the output
@@ -2893,13 +2893,13 @@ NVENCSTATUS NVENCAPI NvEncCreateBitstreamBuffer                 (void* encoder,
  * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncDestroyBitstreamBuffer                (void* encoder, NV_ENC_OUTPUT_PTR bitstreamBuffer);
+NVENCSTATUS NVENCAPI NvEncDestroyBitstreamBuffer                (void *encoder, NV_ENC_OUTPUT_PTR bitstreamBuffer);
 
 // NvEncEncodePicture
 /**
  * \brief Submit an input picture for encoding.
  *
- * This function is used to submit an input picture buffer for encoding. The 
+ * This function is used to submit an input picture buffer for encoding. The
  * encoding parameters are passed using \p *encodePicParams which is a pointer
  * to the ::_NV_ENC_PIC_PARAMS structure.
  *
@@ -2917,62 +2917,62 @@ NVENCSTATUS NVENCAPI NvEncDestroyBitstreamBuffer                (void* encoder,
  * view and view ID as 1 for dependent view.
  *
  *\par Asynchronous Encoding
- * If the client has enabled asynchronous mode of encoding by setting 
+ * If the client has enabled asynchronous mode of encoding by setting
  * NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync to 1 in the ::NvEncInitializeEncoder()
  * API ,then the client must send a valid NV_ENC_PIC_PARAMS::completionEvent.
  * Incase of asynchronous mode of operation, client can queue the ::NvEncEncodePicture()
- * API commands from the main thread and then queue output buffers to be processed 
- * to a secondary worker thread. Before the locking the output buffers in the 
+ * API commands from the main thread and then queue output buffers to be processed
+ * to a secondary worker thread. Before the locking the output buffers in the
  * secondary thread , the client must wait on NV_ENC_PIC_PARAMS::completionEvent
  * it has queued in ::NvEncEncodePicture() API call. The client must always process
  * completion event and the output buffer in the same order in which they have been
- * submitted for encoding. The NvEncodeAPI interface is responsible for any 
+ * submitted for encoding. The NvEncodeAPI interface is responsible for any
  * re-ordering required for B frames and will always ensure that encoded bitstream
  * data is written in the same order in which output buffer is submitted.
  * The NvEncodeAPI interface may return ::NV_ENC_ERR_NEED_MORE_INPUT error code for
  * some ::NvEncEncodePicture() API calls but the client must not treat it as a fatal error.
- * The NvEncodeAPI interface might not be able to submit an input picture buffer for encoding 
+ * The NvEncodeAPI interface might not be able to submit an input picture buffer for encoding
  * immediately due to re-ordering for B frames.
  *\code
   The below example shows how  asynchronous encoding in case of 1 B frames
   ------------------------------------------------------------------------
-  Suppose the client allocated 4 input buffers(I1,I2..), 4 output buffers(O1,O2..) 
-  and 4 completion events(E1, E2, ...). The NvEncodeAPI interface will need to 
-  keep a copy of the input buffers for re-ordering and it allocates following 
+  Suppose the client allocated 4 input buffers(I1,I2..), 4 output buffers(O1,O2..)
+  and 4 completion events(E1, E2, ...). The NvEncodeAPI interface will need to
+  keep a copy of the input buffers for re-ordering and it allocates following
   internal buffers (NvI1, NvI2...). These internal buffers are managed by NvEncodeAPI
-  and the client is not responsible for the allocating or freeing the memory of 
+  and the client is not responsible for the allocating or freeing the memory of
   the internal buffers.
 
-  a) The client main thread will queue the following encode frame calls. 
-  Note the picture type is unknown to the client, the decision is being taken by 
-  NvEncodeAPI interface. The client should pass ::_NV_ENC_PIC_PARAMS parameter  
-  consisting of allocated input buffer, output buffer and output events in successive 
+  a) The client main thread will queue the following encode frame calls.
+  Note the picture type is unknown to the client, the decision is being taken by
+  NvEncodeAPI interface. The client should pass ::_NV_ENC_PIC_PARAMS parameter
+  consisting of allocated input buffer, output buffer and output events in successive
   ::NvEncEncodePicture() API calls along with other required encode picture params.
   For example:
   1st EncodePicture parameters - (I1, O1, E1)
   2nd EncodePicture parameters - (I2, O2, E2)
   3rd EncodePicture parameters - (I3, O3, E3)
 
-  b) NvEncodeAPI SW will receive the following encode Commands from the client. 
-  The left side shows input from client in the form (Input buffer, Output Buffer, 
+  b) NvEncodeAPI SW will receive the following encode Commands from the client.
+  The left side shows input from client in the form (Input buffer, Output Buffer,
   Output Event). The right hand side shows a possible picture type decision take by
   the NvEncodeAPI interface.
   (I1, O1, E1)    ---P1 Frame
   (I2, O2, E2)    ---B2 Frame
   (I3, O3, E3)    ---P3 Frame
 
-  c) NvEncodeAPI interface will make a copy of the input buffers to its internal  
-   buffers for re-ordering. These copies are done as part of nvEncEncodePicture  
-   function call from the client and NvEncodeAPI interface is responsible for  
+  c) NvEncodeAPI interface will make a copy of the input buffers to its internal
+   buffers for re-ordering. These copies are done as part of nvEncEncodePicture
+   function call from the client and NvEncodeAPI interface is responsible for
    synchronization of copy operation with the actual encoding operation.
-   I1 --> NvI1  
-   I2 --> NvI2 
+   I1 --> NvI1
+   I2 --> NvI2
    I3 --> NvI3
 
    d) The NvEncodeAPI encodes I1 as P frame and submits I1 to encoder HW and returns ::NV_ENC_SUCCESS.
    The NvEncodeAPI tries to encode I2 as B frame and fails with ::NV_ENC_ERR_NEED_MORE_INPUT error code.
    The error is not fatal and it notifies client that I2 is not submitted to encoder immediately.
-   The NvEncodeAPI encodes I3 as P frame and submits I3 for encoding which will be used as  backward 
+   The NvEncodeAPI encodes I3 as P frame and submits I3 for encoding which will be used as  backward
    reference frame for I2. The NvEncodeAPI then submits I2 for encoding and returns ::NV_ENC_SUCESS.
    Both the submission are part of the same ::NvEncEncodePicture() function call.
 
@@ -2984,22 +2984,22 @@ NVENCSTATUS NVENCAPI NvEncDestroyBitstreamBuffer                (void* encoder,
    (I1, O1, E1)
    (I2, O2, E2)
    (I3, O3, E3)
-   Note they are in the same order in which client calls ::NvEncEncodePicture() API 
+   Note they are in the same order in which client calls ::NvEncEncodePicture() API
    in \p step a).
 
-  f) NvEncodeAPI interface  will do the re-ordering such that Encoder HW will receive 
+  f) NvEncodeAPI interface  will do the re-ordering such that Encoder HW will receive
   the following encode commands:
   (NvI1, O1, E1)   ---P1 Frame
   (NvI3, O2, E2)   ---P3 Frame
   (NvI2, O3, E3)   ---B2 frame
 
-  g) After the encoding operations are completed, the events will be signaled 
+  g) After the encoding operations are completed, the events will be signaled
   by NvEncodeAPI interface in the following order :
   (O1, E1) ---P1 Frame ,output bitstream copied to O1 and event E1 signaled.
   (O2, E2) ---P3 Frame ,output bitstream copied to O2 and event E2 signaled.
   (O3, E3) ---B2 Frame ,output bitstream copied to O3 and event E3 signaled.
 
-  h) The client must lock the bitstream data using ::NvEncLockBitstream() API in 
+  h) The client must lock the bitstream data using ::NvEncLockBitstream() API in
    the order O1,O2,O3  to read the encoded data, after waiting for the events
    to be signaled in the same order i.e E1, E2 and E3.The output processing is
    done in the secondary thread in the following order:
@@ -3007,57 +3007,57 @@ NVENCSTATUS NVENCAPI NvEncDestroyBitstreamBuffer                (void* encoder,
    Waits on E2, copies encoded bitstream from O2
    Waits on E3, copies encoded bitstream from O3
 
-  -Note the client will receive the events signaling and output buffer in the 
+  -Note the client will receive the events signaling and output buffer in the
    same order in which they have submitted for encoding.
-  -Note the LockBitstream will have picture type field which will notify the 
+  -Note the LockBitstream will have picture type field which will notify the
    output picture type to the clients.
-  -Note the input, output buffer and the output completion event are free to be 
+  -Note the input, output buffer and the output completion event are free to be
    reused once NvEncodeAPI interfaced has signaled the event and the client has
    copied the data from the output buffer.
 
  * \endcode
  *
  *\par Synchronous Encoding
- * The client can enable synchronous mode of encoding by setting 
+ * The client can enable synchronous mode of encoding by setting
  * NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync to 0 in ::NvEncInitializeEncoder() API.
  * The NvEncodeAPI interface may return ::NV_ENC_ERR_NEED_MORE_INPUT error code for
- * some ::NvEncEncodePicture() API calls when NV_ENC_INITIALIZE_PARAMS::enablePTD 
- * is set to 1, but the client must not treat it as a fatal error. The NvEncodeAPI 
- * interface might not be able to submit an input picture buffer for encoding 
- * immediately due to re-ordering for B frames. The NvEncodeAPI interface cannot 
- * submit the input picture which is decided to be encoded as B frame as it waits 
+ * some ::NvEncEncodePicture() API calls when NV_ENC_INITIALIZE_PARAMS::enablePTD
+ * is set to 1, but the client must not treat it as a fatal error. The NvEncodeAPI
+ * interface might not be able to submit an input picture buffer for encoding
+ * immediately due to re-ordering for B frames. The NvEncodeAPI interface cannot
+ * submit the input picture which is decided to be encoded as B frame as it waits
  * for backward reference from  temporally subsequent frames. This input picture
  * is buffered internally and waits for more input picture to arrive. The client
- * must not call ::NvEncLockBitstream() API on the output buffers whose 
- * ::NvEncEncodePicture() API returns ::NV_ENC_ERR_NEED_MORE_INPUT. The client must 
- * wait for the NvEncodeAPI interface to return ::NV_ENC_SUCCESS before locking the 
+ * must not call ::NvEncLockBitstream() API on the output buffers whose
+ * ::NvEncEncodePicture() API returns ::NV_ENC_ERR_NEED_MORE_INPUT. The client must
+ * wait for the NvEncodeAPI interface to return ::NV_ENC_SUCCESS before locking the
  * output bitstreams to read the encoded bitstream data. The following example
  * explains the scenario with synchronous encoding with 2 B frames.
  *\code
  The below example shows how  synchronous encoding works in case of 1 B frames
  -----------------------------------------------------------------------------
- Suppose the client allocated 4 input buffers(I1,I2..), 4 output buffers(O1,O2..) 
- and 4 completion events(E1, E2, ...). The NvEncodeAPI interface will need to 
- keep a copy of the input buffers for re-ordering and it allocates following 
+ Suppose the client allocated 4 input buffers(I1,I2..), 4 output buffers(O1,O2..)
+ and 4 completion events(E1, E2, ...). The NvEncodeAPI interface will need to
+ keep a copy of the input buffers for re-ordering and it allocates following
  internal buffers (NvI1, NvI2...). These internal buffers are managed by NvEncodeAPI
- and the client is not responsible for the allocating or freeing the memory of 
+ and the client is not responsible for the allocating or freeing the memory of
  the internal buffers.
 
  The client calls ::NvEncEncodePicture() API with input buffer I1 and output buffer O1.
  The NvEncodeAPI decides to encode I1 as P frame and submits it to encoder
- HW and returns ::NV_ENC_SUCCESS. 
+ HW and returns ::NV_ENC_SUCCESS.
  The client can now read the encoded data by locking the output O1 by calling
  NvEncLockBitstream API.
 
  The client calls ::NvEncEncodePicture() API with input buffer I2 and output buffer O2.
  The NvEncodeAPI decides to encode I2 as B frame and buffers I2 by copying it
  to internal buffer and returns ::NV_ENC_ERR_NEED_MORE_INPUT.
- The error is not fatal and it notifies client that it cannot read the encoded 
+ The error is not fatal and it notifies client that it cannot read the encoded
  data by locking the output O2 by calling ::NvEncLockBitstream() API without submitting
  more work to the NvEncodeAPI interface.
-  
+
  The client calls ::NvEncEncodePicture() with input buffer I3 and output buffer O3.
- The NvEncodeAPI decides to encode I3 as P frame and it first submits I3 for 
+ The NvEncodeAPI decides to encode I3 as P frame and it first submits I3 for
  encoding which will be used as backward reference frame for I2.
  The NvEncodeAPI then submits I2 for encoding and returns ::NV_ENC_SUCESS. Both
  the submission are part of the same ::NvEncEncodePicture() function call.
@@ -3089,7 +3089,7 @@ NVENCSTATUS NVENCAPI NvEncDestroyBitstreamBuffer                (void* encoder,
  * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncEncodePicture                         (void* encoder, NV_ENC_PIC_PARAMS* encodePicParams);
+NVENCSTATUS NVENCAPI NvEncEncodePicture                         (void *encoder, NV_ENC_PIC_PARAMS *encodePicParams);
 
 
 // NvEncLockBitstream
@@ -3097,16 +3097,16 @@ NVENCSTATUS NVENCAPI NvEncEncodePicture                         (void* encoder,
  * \brief Lock output bitstream buffer
  *
  * This function is used to lock the bitstream buffer to read the encoded data.
- * The client can only access the encoded data by calling this function. 
- * The pointer to client accessible encoded data is returned in the 
+ * The client can only access the encoded data by calling this function.
+ * The pointer to client accessible encoded data is returned in the
  * NV_ENC_LOCK_BITSTREAM::bitstreamBufferPtr field. The size of the encoded data
  * in the output buffer is returned in the NV_ENC_LOCK_BITSTREAM::bitstreamSizeInBytes
- * The NvEncodeAPI interface also returns the output picture type and picture structure 
+ * The NvEncodeAPI interface also returns the output picture type and picture structure
  * of the encoded frame in NV_ENC_LOCK_BITSTREAM::pictureType and
  * NV_ENC_LOCK_BITSTREAM::pictureStruct fields respectively. If the client has
  * set NV_ENC_LOCK_BITSTREAM::doNotWait to 1, the function might return
- * ::NV_ENC_ERR_LOCK_BUSY if client is operating in synchronous mode. This is not 
- * a fatal failure if NV_ENC_LOCK_BITSTREAM::doNotWait is set to 1. In the above case the client can 
+ * ::NV_ENC_ERR_LOCK_BUSY if client is operating in synchronous mode. This is not
+ * a fatal failure if NV_ENC_LOCK_BITSTREAM::doNotWait is set to 1. In the above case the client can
  * retry the function after few milliseconds.
  *
  * \param [in] encoder
@@ -3128,7 +3128,7 @@ NVENCSTATUS NVENCAPI NvEncEncodePicture                         (void* encoder,
  * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncLockBitstream                         (void* encoder, NV_ENC_LOCK_BITSTREAM* lockBitstreamBufferParams);
+NVENCSTATUS NVENCAPI NvEncLockBitstream                         (void *encoder, NV_ENC_LOCK_BITSTREAM *lockBitstreamBufferParams);
 
 
 // NvEncUnlockBitstream
@@ -3158,7 +3158,7 @@ NVENCSTATUS NVENCAPI NvEncLockBitstream                         (void* encoder,
  * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncUnlockBitstream                       (void* encoder, NV_ENC_OUTPUT_PTR bitstreamBuffer);
+NVENCSTATUS NVENCAPI NvEncUnlockBitstream                       (void *encoder, NV_ENC_OUTPUT_PTR bitstreamBuffer);
 
 
 // NvLockInputBuffer
@@ -3168,9 +3168,9 @@ NVENCSTATUS NVENCAPI NvEncUnlockBitstream                       (void* encoder,
  * This function is used to lock the input buffer to load the uncompressed YUV
  * pixel data into input buffer memory. The client must pass the NV_ENC_INPUT_PTR
  * it had previously allocated using ::NvEncCreateInputBuffer()in the
- * NV_ENC_LOCK_INPUT_BUFFER::inputBuffer field. 
- * The NvEncodeAPI interface returns pointer to client accessible input buffer 
- * memory in NV_ENC_LOCK_INPUT_BUFFER::bufferDataPtr field. 
+ * NV_ENC_LOCK_INPUT_BUFFER::inputBuffer field.
+ * The NvEncodeAPI interface returns pointer to client accessible input buffer
+ * memory in NV_ENC_LOCK_INPUT_BUFFER::bufferDataPtr field.
  *
  * \param [in] encoder
  *   Pointer to the NvEncodeAPI interface.
@@ -3192,7 +3192,7 @@ NVENCSTATUS NVENCAPI NvEncUnlockBitstream                       (void* encoder,
  * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncLockInputBuffer                      (void* encoder, NV_ENC_LOCK_INPUT_BUFFER* lockInputBufferParams);
+NVENCSTATUS NVENCAPI NvEncLockInputBuffer                      (void *encoder, NV_ENC_LOCK_INPUT_BUFFER *lockInputBufferParams);
 
 
 // NvUnlockInputBuffer
@@ -3222,7 +3222,7 @@ NVENCSTATUS NVENCAPI NvEncLockInputBuffer                      (void* encoder, N
  *
  *
  */
-NVENCSTATUS NVENCAPI NvEncUnlockInputBuffer                     (void* encoder, NV_ENC_INPUT_PTR inputBuffer);
+NVENCSTATUS NVENCAPI NvEncUnlockInputBuffer                     (void *encoder, NV_ENC_INPUT_PTR inputBuffer);
 
 
 // NvEncGetEncodeStats
@@ -3249,23 +3249,23 @@ NVENCSTATUS NVENCAPI NvEncUnlockInputBuffer                     (void* encoder,
  * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncGetEncodeStats                        (void* encoder, NV_ENC_STAT* encodeStats);
+NVENCSTATUS NVENCAPI NvEncGetEncodeStats                        (void *encoder, NV_ENC_STAT *encodeStats);
 
 
 // NvEncGetSequenceParams
 /**
  * \brief Get encoded sequence and picture header.
  *
- * This function can be used to retrieve the sequence and picture header out of 
- * band. The client must call this function only after the encoder has been 
- * initialized using ::NvEncInitializeEncoder() function. The client must 
+ * This function can be used to retrieve the sequence and picture header out of
+ * band. The client must call this function only after the encoder has been
+ * initialized using ::NvEncInitializeEncoder() function. The client must
  * allocate the memory where the NvEncodeAPI interface can copy the bitstream
- * header and pass the pointer to the memory in NV_ENC_SEQUENCE_PARAM_PAYLOAD::spsppsBuffer. 
+ * header and pass the pointer to the memory in NV_ENC_SEQUENCE_PARAM_PAYLOAD::spsppsBuffer.
  * The size of buffer is passed in the field  NV_ENC_SEQUENCE_PARAM_PAYLOAD::inBufferSize.
- * The NvEncodeAPI interface will copy the bitstream header payload and returns 
+ * The NvEncodeAPI interface will copy the bitstream header payload and returns
  * the actual size of the bitstream header in the field
  * NV_ENC_SEQUENCE_PARAM_PAYLOAD::outSPSPPSPayloadSize.
- * The client must call  ::NvEncGetSequenceParams() function from the same thread which is 
+ * The client must call  ::NvEncGetSequenceParams() function from the same thread which is
  * being used to call ::NvEncEncodePicture() function.
  *
  * \param [in] encoder
@@ -3283,25 +3283,25 @@ NVENCSTATUS NVENCAPI NvEncGetEncodeStats                        (void* encoder,
  * ::NV_ENC_ERR_INVALID_VERSION \n
  * ::NV_ENC_ERR_INVALID_PARAM \n
  * ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \n
- * ::NV_ENC_ERR_GENERIC \n 
+ * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncGetSequenceParams                     (void* encoder, NV_ENC_SEQUENCE_PARAM_PAYLOAD* sequenceParamPayload);
+NVENCSTATUS NVENCAPI NvEncGetSequenceParams                     (void *encoder, NV_ENC_SEQUENCE_PARAM_PAYLOAD *sequenceParamPayload);
 
 // NvEncGetSequenceParamEx
 /**
  * \brief Get sequence and picture header.
  *
  * This function can be used to retrieve the sequence and picture header out of band, even when
- * encoder has not been initialized using ::NvEncInitializeEncoder() function. 
+ * encoder has not been initialized using ::NvEncInitializeEncoder() function.
  * The client must allocate the memory where the NvEncodeAPI interface can copy the bitstream
- * header and pass the pointer to the memory in NV_ENC_SEQUENCE_PARAM_PAYLOAD::spsppsBuffer. 
- * The size of buffer is passed in the field  NV_ENC_SEQUENCE_PARAM_PAYLOAD::inBufferSize. 
- * If encoder has not been initialized using ::NvEncInitializeEncoder() function, client must 
- * send NV_ENC_INITIALIZE_PARAMS as input. The NV_ENC_INITIALIZE_PARAMS passed must be same as the 
+ * header and pass the pointer to the memory in NV_ENC_SEQUENCE_PARAM_PAYLOAD::spsppsBuffer.
+ * The size of buffer is passed in the field  NV_ENC_SEQUENCE_PARAM_PAYLOAD::inBufferSize.
+ * If encoder has not been initialized using ::NvEncInitializeEncoder() function, client must
+ * send NV_ENC_INITIALIZE_PARAMS as input. The NV_ENC_INITIALIZE_PARAMS passed must be same as the
  * one which will be used for initializing encoder using ::NvEncInitializeEncoder() function later.
- * If encoder is already initialized using ::NvEncInitializeEncoder() function, the provided 
- * NV_ENC_INITIALIZE_PARAMS structure is ignored. The NvEncodeAPI interface will copy the bitstream 
+ * If encoder is already initialized using ::NvEncInitializeEncoder() function, the provided
+ * NV_ENC_INITIALIZE_PARAMS structure is ignored. The NvEncodeAPI interface will copy the bitstream
  * header payload and returns the actual size of the bitstream header in the field
  * NV_ENC_SEQUENCE_PARAM_PAYLOAD::outSPSPPSPayloadSize. The client must call  ::NvEncGetSequenceParamsEx()
  * function from the same thread which is being used to call ::NvEncEncodePicture() function.
@@ -3322,20 +3322,20 @@ NVENCSTATUS NVENCAPI NvEncGetSequenceParams                     (void* encoder,
  * ::NV_ENC_ERR_OUT_OF_MEMORY \n
  * ::NV_ENC_ERR_INVALID_VERSION \n
  * ::NV_ENC_ERR_INVALID_PARAM \n
- * ::NV_ENC_ERR_GENERIC \n 
+ * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncGetSequenceParamEx                     (void* encoder, NV_ENC_INITIALIZE_PARAMS* encInitParams, NV_ENC_SEQUENCE_PARAM_PAYLOAD* sequenceParamPayload);
+NVENCSTATUS NVENCAPI NvEncGetSequenceParamEx                     (void *encoder, NV_ENC_INITIALIZE_PARAMS *encInitParams, NV_ENC_SEQUENCE_PARAM_PAYLOAD *sequenceParamPayload);
 
 // NvEncRegisterAsyncEvent
 /**
  * \brief Register event for notification to encoding completion.
  *
- * This function is used to register the completion event with NvEncodeAPI 
- * interface. The event is required when the client has configured the encoder to 
+ * This function is used to register the completion event with NvEncodeAPI
+ * interface. The event is required when the client has configured the encoder to
  * work in asynchronous mode. In this mode the client needs to send a completion
- * event with every output buffer. The NvEncodeAPI interface will signal the 
- * completion of the encoding process using this event. Only after the event is 
+ * event with every output buffer. The NvEncodeAPI interface will signal the
+ * completion of the encoding process using this event. Only after the event is
  * signaled the client can get the encoded data using ::NvEncLockBitstream() function.
  *
  * \param [in] encoder
@@ -3356,7 +3356,7 @@ NVENCSTATUS NVENCAPI NvEncGetSequenceParamEx                     (void* encoder,
  * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncRegisterAsyncEvent                    (void* encoder, NV_ENC_EVENT_PARAMS* eventParams);
+NVENCSTATUS NVENCAPI NvEncRegisterAsyncEvent                    (void *encoder, NV_ENC_EVENT_PARAMS *eventParams);
 
 
 // NvEncUnregisterAsyncEvent
@@ -3385,10 +3385,10 @@ NVENCSTATUS NVENCAPI NvEncRegisterAsyncEvent                    (void* encoder,
  * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncUnregisterAsyncEvent                  (void* encoder, NV_ENC_EVENT_PARAMS* eventParams);
+NVENCSTATUS NVENCAPI NvEncUnregisterAsyncEvent                  (void *encoder, NV_ENC_EVENT_PARAMS *eventParams);
 
 
-// NvEncMapInputResource 
+// NvEncMapInputResource
 /**
  * \brief Map an externally created input resource pointer for encoding.
  *
@@ -3424,10 +3424,10 @@ NVENCSTATUS NVENCAPI NvEncUnregisterAsyncEvent                  (void* encoder,
  * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncMapInputResource                         (void* encoder, NV_ENC_MAP_INPUT_RESOURCE* mapInputResParams);
+NVENCSTATUS NVENCAPI NvEncMapInputResource                         (void *encoder, NV_ENC_MAP_INPUT_RESOURCE *mapInputResParams);
 
 
-// NvEncUnmapInputResource 
+// NvEncUnmapInputResource
 /**
  * \brief  UnMaps a NV_ENC_INPUT_PTR  which was mapped for encoding
  *
@@ -3459,21 +3459,21 @@ NVENCSTATUS NVENCAPI NvEncMapInputResource                         (void* encode
  * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncUnmapInputResource                         (void* encoder, NV_ENC_INPUT_PTR mappedInputBuffer);
+NVENCSTATUS NVENCAPI NvEncUnmapInputResource                         (void *encoder, NV_ENC_INPUT_PTR mappedInputBuffer);
 
 // NvEncDestroyEncoder
 /**
  * \brief Destroy Encoding Session
  *
  * Destroys the encoder session previously created using ::NvEncOpenEncodeSession()
- * function. The client must flush the encoder before freeing any resources. In order 
- * to flush the encoder the client must pass a NULL encode picture packet and either 
- * wait for the ::NvEncEncodePicture() function to return in synchronous mode or wait 
+ * function. The client must flush the encoder before freeing any resources. In order
+ * to flush the encoder the client must pass a NULL encode picture packet and either
+ * wait for the ::NvEncEncodePicture() function to return in synchronous mode or wait
  * for the flush event to be signaled by the encoder in asynchronous mode.
  * The client must free all the input and output resources created using the
  * NvEncodeAPI interface before destroying the encoder. If the client is operating
  * in asynchronous mode, it must also unregister the completion events previously
- * registered. 
+ * registered.
  *
  * \param [in] encoder
  *   Pointer to the NvEncodeAPI interface.
@@ -3489,19 +3489,19 @@ NVENCSTATUS NVENCAPI NvEncUnmapInputResource                         (void* enco
  * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncDestroyEncoder                        (void* encoder);
+NVENCSTATUS NVENCAPI NvEncDestroyEncoder                        (void *encoder);
 
 // NvEncInvalidateRefFrames
 /**
- * \brief Invalidate reference frames 
+ * \brief Invalidate reference frames
  *
- * Invalidates reference frame based on the time stamp provided by the client. 
+ * Invalidates reference frame based on the time stamp provided by the client.
  * The encoder marks any reference frames or any frames which have been reconstructed
  * using the corrupt frame as invalid for motion estimation and uses older reference
  * frames for motion estimation. The encoded forces the current frame to be encoded
  * as an intra frame if no reference frames are left after invalidation process.
- * This is useful for low latency application for error resiliency. The client 
- * is recommended to set NV_ENC_CONFIG_H264::maxNumRefFrames to a large value so 
+ * This is useful for low latency application for error resiliency. The client
+ * is recommended to set NV_ENC_CONFIG_H264::maxNumRefFrames to a large value so
  * that encoder can keep a backup of older reference frames in the DPB and can use them
  * for motion estimation when the newer reference frames have been invalidated.
  * This API can be called multiple times.
@@ -3522,19 +3522,19 @@ NVENCSTATUS NVENCAPI NvEncDestroyEncoder                        (void* encoder);
  * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncInvalidateRefFrames(void* encoder, uint64_t invalidRefFrameTimeStamp);
+NVENCSTATUS NVENCAPI NvEncInvalidateRefFrames(void *encoder, uint64_t invalidRefFrameTimeStamp);
 
 // NvEncOpenEncodeSessionEx
 /**
  * \brief Opens an encoding session.
- * 
+ *
  * Opens an encoding session and returns a pointer to the encoder interface in
  * the \p **encoder parameter. The client should start encoding process by calling
- * this API first. 
+ * this API first.
  * The client must pass a pointer to IDirect3DDevice9 device or CUDA context in the \p *device parameter.
  * For the OpenGL interface, \p device must be NULL. An OpenGL context must be current when
  * calling all NvEncodeAPI functions.
- * If the creation of encoder session fails, the client must call ::NvEncDestroyEncoder API 
+ * If the creation of encoder session fails, the client must call ::NvEncDestroyEncoder API
  * before exiting.
  *
  * \param [in] openSessionExParams
@@ -3552,12 +3552,12 @@ NVENCSTATUS NVENCAPI NvEncInvalidateRefFrames(void* encoder, uint64_t invalidRef
  * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncOpenEncodeSessionEx                   (NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS *openSessionExParams, void** encoder);
+NVENCSTATUS NVENCAPI NvEncOpenEncodeSessionEx                   (NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS *openSessionExParams, void **encoder);
 
 // NvEncRegisterResource
 /**
  * \brief Registers a resource with the Nvidia Video Encoder Interface.
- * 
+ *
  * Registers a resource with the Nvidia Video Encoder Interface for book keeping.
  * The client is expected to pass the registered resource handle as well, while calling ::NvEncMapInputResource API.
  *
@@ -3566,7 +3566,7 @@ NVENCSTATUS NVENCAPI NvEncOpenEncodeSessionEx                   (NV_ENC_OPEN_ENC
  *
  * \param [in] registerResParams
  *   Pointer to a ::_NV_ENC_REGISTER_RESOURCE structure
- * 
+ *
  * \return
  * ::NV_ENC_SUCCESS \n
  * ::NV_ENC_ERR_INVALID_PTR \n
@@ -3582,14 +3582,14 @@ NVENCSTATUS NVENCAPI NvEncOpenEncodeSessionEx                   (NV_ENC_OPEN_ENC
  * ::NV_ENC_ERR_UNIMPLEMENTED \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncRegisterResource                      (void* encoder, NV_ENC_REGISTER_RESOURCE* registerResParams);
+NVENCSTATUS NVENCAPI NvEncRegisterResource                      (void *encoder, NV_ENC_REGISTER_RESOURCE *registerResParams);
 
 // NvEncUnregisterResource
 /**
  * \brief Unregisters a resource previously registered with the Nvidia Video Encoder Interface.
- * 
+ *
  * Unregisters a resource previously registered with the Nvidia Video Encoder Interface.
- * The client is expected to unregister any resource that it has registered with the 
+ * The client is expected to unregister any resource that it has registered with the
  * Nvidia Video Encoder Interface before destroying the resource.
  *
  * \param [in] encoder
@@ -3613,21 +3613,21 @@ NVENCSTATUS NVENCAPI NvEncRegisterResource                      (void* encoder,
  * ::NV_ENC_ERR_UNIMPLEMENTED \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncUnregisterResource                    (void* encoder, NV_ENC_REGISTERED_PTR registeredResource);
+NVENCSTATUS NVENCAPI NvEncUnregisterResource                    (void *encoder, NV_ENC_REGISTERED_PTR registeredResource);
 
 // NvEncReconfigureEncoder
 /**
  * \brief Reconfigure an existing encoding session.
- * 
+ *
  * Reconfigure an existing encoding session.
- * The client should call this API to change/reconfigure the parameter passed during 
+ * The client should call this API to change/reconfigure the parameter passed during
  * NvEncInitializeEncoder API call.
  * Currently Reconfiguration of following are not supported.
  * Change in GOP structure.
  * Change in sync-Async mode.
  * Change in MaxWidth & MaxHeight.
  * Change in PTD mode.
- * 
+ *
  * Resolution change is possible only if maxEncodeWidth & maxEncodeHeight of NV_ENC_INITIALIZE_PARAMS
  * is set while creating encoder session.
  *
@@ -3647,7 +3647,7 @@ NVENCSTATUS NVENCAPI NvEncUnregisterResource                    (void* encoder,
  * ::NV_ENC_ERR_GENERIC \n
  *
  */
-NVENCSTATUS NVENCAPI NvEncReconfigureEncoder                   (void *encoder, NV_ENC_RECONFIGURE_PARAMS* reInitEncodeParams);
+NVENCSTATUS NVENCAPI NvEncReconfigureEncoder                   (void *encoder, NV_ENC_RECONFIGURE_PARAMS *reInitEncodeParams);
 
 
 
@@ -3678,7 +3678,7 @@ NVENCSTATUS NVENCAPI NvEncReconfigureEncoder                   (void *encoder, N
  * ::NV_ENC_ERR_INVALID_VERSION \n
  * ::NV_ENC_ERR_GENERIC \n
  */
-NVENCSTATUS NVENCAPI NvEncCreateMVBuffer                        (void* encoder, NV_ENC_CREATE_MV_BUFFER* createMVBufferParams);
+NVENCSTATUS NVENCAPI NvEncCreateMVBuffer                        (void *encoder, NV_ENC_CREATE_MV_BUFFER *createMVBufferParams);
 
 
 // NvEncDestroyMVBuffer
@@ -3706,7 +3706,7 @@ NVENCSTATUS NVENCAPI NvEncCreateMVBuffer                        (void* encoder,
  * ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \n
  * ::NV_ENC_ERR_GENERIC \n
  */
-NVENCSTATUS NVENCAPI NvEncDestroyMVBuffer                       (void* encoder, NV_ENC_OUTPUT_PTR mvBuffer);
+NVENCSTATUS NVENCAPI NvEncDestroyMVBuffer                       (void *encoder, NV_ENC_OUTPUT_PTR mvBuffer);
 
 
 // NvEncRunMotionEstimationOnly
@@ -3737,7 +3737,7 @@ NVENCSTATUS NVENCAPI NvEncDestroyMVBuffer                       (void* encoder,
  * ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \n
  * ::NV_ENC_ERR_GENERIC \n
  */
-NVENCSTATUS NVENCAPI NvEncRunMotionEstimationOnly               (void* encoder, NV_ENC_MEONLY_PARAMS* meOnlyParams);
+NVENCSTATUS NVENCAPI NvEncRunMotionEstimationOnly               (void *encoder, NV_ENC_MEONLY_PARAMS *meOnlyParams);
 
 // NvEncodeAPIGetMaxSupportedVersion
 /**
@@ -3755,7 +3755,7 @@ NVENCSTATUS NVENCAPI NvEncRunMotionEstimationOnly               (void* encoder,
  * ::NV_ENC_SUCCESS \n
  * ::NV_ENC_ERR_INVALID_PTR \n
  */
-NVENCSTATUS NVENCAPI NvEncodeAPIGetMaxSupportedVersion          (uint32_t* version);
+NVENCSTATUS NVENCAPI NvEncodeAPIGetMaxSupportedVersion          (uint32_t *version);
 
 
 // NvEncGetLastErrorString
@@ -3771,54 +3771,54 @@ NVENCSTATUS NVENCAPI NvEncodeAPIGetMaxSupportedVersion          (uint32_t* versi
  * \return
  *   Pointer to buffer containing the details of the last error encountered by the API.
  */
-const char * NVENCAPI NvEncGetLastErrorString          (void* encoder);
+const char *NVENCAPI NvEncGetLastErrorString          (void *encoder);
 
 
 /// \cond API PFN
 /*
- *  Defines API function pointers 
- */
-typedef NVENCSTATUS (NVENCAPI* PNVENCOPENENCODESESSION)         (void* device, uint32_t deviceType, void** encoder);
-typedef NVENCSTATUS (NVENCAPI* PNVENCGETENCODEGUIDCOUNT)        (void* encoder, uint32_t* encodeGUIDCount);
-typedef NVENCSTATUS (NVENCAPI* PNVENCGETENCODEGUIDS)            (void* encoder, GUID* GUIDs, uint32_t guidArraySize, uint32_t* GUIDCount);
-typedef NVENCSTATUS (NVENCAPI* PNVENCGETENCODEPROFILEGUIDCOUNT) (void* encoder, GUID encodeGUID, uint32_t* encodeProfileGUIDCount);
-typedef NVENCSTATUS (NVENCAPI* PNVENCGETENCODEPROFILEGUIDS)     (void* encoder, GUID encodeGUID, GUID* profileGUIDs, uint32_t guidArraySize, uint32_t* GUIDCount);
-typedef NVENCSTATUS (NVENCAPI* PNVENCGETINPUTFORMATCOUNT)       (void* encoder, GUID encodeGUID, uint32_t* inputFmtCount);
-typedef NVENCSTATUS (NVENCAPI* PNVENCGETINPUTFORMATS)           (void* encoder, GUID encodeGUID, NV_ENC_BUFFER_FORMAT* inputFmts, uint32_t inputFmtArraySize, uint32_t* inputFmtCount);
-typedef NVENCSTATUS (NVENCAPI* PNVENCGETENCODECAPS)             (void* encoder, GUID encodeGUID, NV_ENC_CAPS_PARAM* capsParam, int* capsVal);
-typedef NVENCSTATUS (NVENCAPI* PNVENCGETENCODEPRESETCOUNT)      (void* encoder, GUID encodeGUID, uint32_t* encodePresetGUIDCount);
-typedef NVENCSTATUS (NVENCAPI* PNVENCGETENCODEPRESETGUIDS)      (void* encoder, GUID encodeGUID, GUID* presetGUIDs, uint32_t guidArraySize, uint32_t* encodePresetGUIDCount);
-typedef NVENCSTATUS (NVENCAPI* PNVENCGETENCODEPRESETCONFIG)     (void* encoder, GUID encodeGUID, GUID  presetGUID, NV_ENC_PRESET_CONFIG* presetConfig);
-typedef NVENCSTATUS (NVENCAPI* PNVENCGETENCODEPRESETCONFIGEX)   (void* encoder, GUID encodeGUID, GUID  presetGUID, NV_ENC_TUNING_INFO tuningInfo, NV_ENC_PRESET_CONFIG* presetConfig);
-typedef NVENCSTATUS (NVENCAPI* PNVENCINITIALIZEENCODER)         (void* encoder, NV_ENC_INITIALIZE_PARAMS* createEncodeParams);
-typedef NVENCSTATUS (NVENCAPI* PNVENCCREATEINPUTBUFFER)         (void* encoder, NV_ENC_CREATE_INPUT_BUFFER* createInputBufferParams);
-typedef NVENCSTATUS (NVENCAPI* PNVENCDESTROYINPUTBUFFER)        (void* encoder, NV_ENC_INPUT_PTR inputBuffer);
-typedef NVENCSTATUS (NVENCAPI* PNVENCCREATEBITSTREAMBUFFER)     (void* encoder, NV_ENC_CREATE_BITSTREAM_BUFFER* createBitstreamBufferParams);
-typedef NVENCSTATUS (NVENCAPI* PNVENCDESTROYBITSTREAMBUFFER)    (void* encoder, NV_ENC_OUTPUT_PTR bitstreamBuffer);
-typedef NVENCSTATUS (NVENCAPI* PNVENCENCODEPICTURE)             (void* encoder, NV_ENC_PIC_PARAMS* encodePicParams);
-typedef NVENCSTATUS (NVENCAPI* PNVENCLOCKBITSTREAM)             (void* encoder, NV_ENC_LOCK_BITSTREAM* lockBitstreamBufferParams);
-typedef NVENCSTATUS (NVENCAPI* PNVENCUNLOCKBITSTREAM)           (void* encoder, NV_ENC_OUTPUT_PTR bitstreamBuffer);
-typedef NVENCSTATUS (NVENCAPI* PNVENCLOCKINPUTBUFFER)           (void* encoder, NV_ENC_LOCK_INPUT_BUFFER* lockInputBufferParams);
-typedef NVENCSTATUS (NVENCAPI* PNVENCUNLOCKINPUTBUFFER)         (void* encoder, NV_ENC_INPUT_PTR inputBuffer);
-typedef NVENCSTATUS (NVENCAPI* PNVENCGETENCODESTATS)            (void* encoder, NV_ENC_STAT* encodeStats);
-typedef NVENCSTATUS (NVENCAPI* PNVENCGETSEQUENCEPARAMS)         (void* encoder, NV_ENC_SEQUENCE_PARAM_PAYLOAD* sequenceParamPayload);
-typedef NVENCSTATUS (NVENCAPI* PNVENCREGISTERASYNCEVENT)        (void* encoder, NV_ENC_EVENT_PARAMS* eventParams);
-typedef NVENCSTATUS (NVENCAPI* PNVENCUNREGISTERASYNCEVENT)      (void* encoder, NV_ENC_EVENT_PARAMS* eventParams);
-typedef NVENCSTATUS (NVENCAPI* PNVENCMAPINPUTRESOURCE)          (void* encoder, NV_ENC_MAP_INPUT_RESOURCE* mapInputResParams);
-typedef NVENCSTATUS (NVENCAPI* PNVENCUNMAPINPUTRESOURCE)        (void* encoder, NV_ENC_INPUT_PTR mappedInputBuffer);
-typedef NVENCSTATUS (NVENCAPI* PNVENCDESTROYENCODER)            (void* encoder);
-typedef NVENCSTATUS (NVENCAPI* PNVENCINVALIDATEREFFRAMES)       (void* encoder, uint64_t invalidRefFrameTimeStamp);
-typedef NVENCSTATUS (NVENCAPI* PNVENCOPENENCODESESSIONEX)       (NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS *openSessionExParams, void** encoder);
-typedef NVENCSTATUS (NVENCAPI* PNVENCREGISTERRESOURCE)          (void* encoder, NV_ENC_REGISTER_RESOURCE* registerResParams);
-typedef NVENCSTATUS (NVENCAPI* PNVENCUNREGISTERRESOURCE)        (void* encoder, NV_ENC_REGISTERED_PTR registeredRes);
-typedef NVENCSTATUS (NVENCAPI* PNVENCRECONFIGUREENCODER)        (void* encoder, NV_ENC_RECONFIGURE_PARAMS* reInitEncodeParams);
-
-typedef NVENCSTATUS (NVENCAPI* PNVENCCREATEMVBUFFER)            (void* encoder, NV_ENC_CREATE_MV_BUFFER* createMVBufferParams);
-typedef NVENCSTATUS (NVENCAPI* PNVENCDESTROYMVBUFFER)           (void* encoder, NV_ENC_OUTPUT_PTR mvBuffer);
-typedef NVENCSTATUS (NVENCAPI* PNVENCRUNMOTIONESTIMATIONONLY)   (void* encoder, NV_ENC_MEONLY_PARAMS* meOnlyParams);
-typedef const char * (NVENCAPI* PNVENCGETLASTERROR)             (void* encoder);
-typedef NVENCSTATUS (NVENCAPI* PNVENCSETIOCUDASTREAMS)          (void* encoder, NV_ENC_CUSTREAM_PTR inputStream, NV_ENC_CUSTREAM_PTR outputStream);
-typedef NVENCSTATUS (NVENCAPI* PNVENCGETSEQUENCEPARAMEX)        (void* encoder, NV_ENC_INITIALIZE_PARAMS* encInitParams, NV_ENC_SEQUENCE_PARAM_PAYLOAD* sequenceParamPayload);
+ *  Defines API function pointers
+ */
+typedef NVENCSTATUS (NVENCAPI *PNVENCOPENENCODESESSION)         (void *device, uint32_t deviceType, void **encoder);
+typedef NVENCSTATUS (NVENCAPI *PNVENCGETENCODEGUIDCOUNT)        (void *encoder, uint32_t *encodeGUIDCount);
+typedef NVENCSTATUS (NVENCAPI *PNVENCGETENCODEGUIDS)            (void *encoder, GUID *GUIDs, uint32_t guidArraySize, uint32_t *GUIDCount);
+typedef NVENCSTATUS (NVENCAPI *PNVENCGETENCODEPROFILEGUIDCOUNT) (void *encoder, GUID encodeGUID, uint32_t *encodeProfileGUIDCount);
+typedef NVENCSTATUS (NVENCAPI *PNVENCGETENCODEPROFILEGUIDS)     (void *encoder, GUID encodeGUID, GUID *profileGUIDs, uint32_t guidArraySize, uint32_t *GUIDCount);
+typedef NVENCSTATUS (NVENCAPI *PNVENCGETINPUTFORMATCOUNT)       (void *encoder, GUID encodeGUID, uint32_t *inputFmtCount);
+typedef NVENCSTATUS (NVENCAPI *PNVENCGETINPUTFORMATS)           (void *encoder, GUID encodeGUID, NV_ENC_BUFFER_FORMAT *inputFmts, uint32_t inputFmtArraySize, uint32_t *inputFmtCount);
+typedef NVENCSTATUS (NVENCAPI *PNVENCGETENCODECAPS)             (void *encoder, GUID encodeGUID, NV_ENC_CAPS_PARAM *capsParam, int *capsVal);
+typedef NVENCSTATUS (NVENCAPI *PNVENCGETENCODEPRESETCOUNT)      (void *encoder, GUID encodeGUID, uint32_t *encodePresetGUIDCount);
+typedef NVENCSTATUS (NVENCAPI *PNVENCGETENCODEPRESETGUIDS)      (void *encoder, GUID encodeGUID, GUID *presetGUIDs, uint32_t guidArraySize, uint32_t *encodePresetGUIDCount);
+typedef NVENCSTATUS (NVENCAPI *PNVENCGETENCODEPRESETCONFIG)     (void *encoder, GUID encodeGUID, GUID  presetGUID, NV_ENC_PRESET_CONFIG *presetConfig);
+typedef NVENCSTATUS (NVENCAPI *PNVENCGETENCODEPRESETCONFIGEX)   (void *encoder, GUID encodeGUID, GUID  presetGUID, NV_ENC_TUNING_INFO tuningInfo, NV_ENC_PRESET_CONFIG *presetConfig);
+typedef NVENCSTATUS (NVENCAPI *PNVENCINITIALIZEENCODER)         (void *encoder, NV_ENC_INITIALIZE_PARAMS *createEncodeParams);
+typedef NVENCSTATUS (NVENCAPI *PNVENCCREATEINPUTBUFFER)         (void *encoder, NV_ENC_CREATE_INPUT_BUFFER *createInputBufferParams);
+typedef NVENCSTATUS (NVENCAPI *PNVENCDESTROYINPUTBUFFER)        (void *encoder, NV_ENC_INPUT_PTR inputBuffer);
+typedef NVENCSTATUS (NVENCAPI *PNVENCCREATEBITSTREAMBUFFER)     (void *encoder, NV_ENC_CREATE_BITSTREAM_BUFFER *createBitstreamBufferParams);
+typedef NVENCSTATUS (NVENCAPI *PNVENCDESTROYBITSTREAMBUFFER)    (void *encoder, NV_ENC_OUTPUT_PTR bitstreamBuffer);
+typedef NVENCSTATUS (NVENCAPI *PNVENCENCODEPICTURE)             (void *encoder, NV_ENC_PIC_PARAMS *encodePicParams);
+typedef NVENCSTATUS (NVENCAPI *PNVENCLOCKBITSTREAM)             (void *encoder, NV_ENC_LOCK_BITSTREAM *lockBitstreamBufferParams);
+typedef NVENCSTATUS (NVENCAPI *PNVENCUNLOCKBITSTREAM)           (void *encoder, NV_ENC_OUTPUT_PTR bitstreamBuffer);
+typedef NVENCSTATUS (NVENCAPI *PNVENCLOCKINPUTBUFFER)           (void *encoder, NV_ENC_LOCK_INPUT_BUFFER *lockInputBufferParams);
+typedef NVENCSTATUS (NVENCAPI *PNVENCUNLOCKINPUTBUFFER)         (void *encoder, NV_ENC_INPUT_PTR inputBuffer);
+typedef NVENCSTATUS (NVENCAPI *PNVENCGETENCODESTATS)            (void *encoder, NV_ENC_STAT *encodeStats);
+typedef NVENCSTATUS (NVENCAPI *PNVENCGETSEQUENCEPARAMS)         (void *encoder, NV_ENC_SEQUENCE_PARAM_PAYLOAD *sequenceParamPayload);
+typedef NVENCSTATUS (NVENCAPI *PNVENCREGISTERASYNCEVENT)        (void *encoder, NV_ENC_EVENT_PARAMS *eventParams);
+typedef NVENCSTATUS (NVENCAPI *PNVENCUNREGISTERASYNCEVENT)      (void *encoder, NV_ENC_EVENT_PARAMS *eventParams);
+typedef NVENCSTATUS (NVENCAPI *PNVENCMAPINPUTRESOURCE)          (void *encoder, NV_ENC_MAP_INPUT_RESOURCE *mapInputResParams);
+typedef NVENCSTATUS (NVENCAPI *PNVENCUNMAPINPUTRESOURCE)        (void *encoder, NV_ENC_INPUT_PTR mappedInputBuffer);
+typedef NVENCSTATUS (NVENCAPI *PNVENCDESTROYENCODER)            (void *encoder);
+typedef NVENCSTATUS (NVENCAPI *PNVENCINVALIDATEREFFRAMES)       (void *encoder, uint64_t invalidRefFrameTimeStamp);
+typedef NVENCSTATUS (NVENCAPI *PNVENCOPENENCODESESSIONEX)       (NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS *openSessionExParams, void **encoder);
+typedef NVENCSTATUS (NVENCAPI *PNVENCREGISTERRESOURCE)          (void *encoder, NV_ENC_REGISTER_RESOURCE *registerResParams);
+typedef NVENCSTATUS (NVENCAPI *PNVENCUNREGISTERRESOURCE)        (void *encoder, NV_ENC_REGISTERED_PTR registeredRes);
+typedef NVENCSTATUS (NVENCAPI *PNVENCRECONFIGUREENCODER)        (void *encoder, NV_ENC_RECONFIGURE_PARAMS *reInitEncodeParams);
+
+typedef NVENCSTATUS (NVENCAPI *PNVENCCREATEMVBUFFER)            (void *encoder, NV_ENC_CREATE_MV_BUFFER *createMVBufferParams);
+typedef NVENCSTATUS (NVENCAPI *PNVENCDESTROYMVBUFFER)           (void *encoder, NV_ENC_OUTPUT_PTR mvBuffer);
+typedef NVENCSTATUS (NVENCAPI *PNVENCRUNMOTIONESTIMATIONONLY)   (void *encoder, NV_ENC_MEONLY_PARAMS *meOnlyParams);
+typedef const char *(NVENCAPI *PNVENCGETLASTERROR)             (void *encoder);
+typedef NVENCSTATUS (NVENCAPI *PNVENCSETIOCUDASTREAMS)          (void *encoder, NV_ENC_CUSTREAM_PTR inputStream, NV_ENC_CUSTREAM_PTR outputStream);
+typedef NVENCSTATUS (NVENCAPI *PNVENCGETSEQUENCEPARAMEX)        (void *encoder, NV_ENC_INITIALIZE_PARAMS *encInitParams, NV_ENC_SEQUENCE_PARAM_PAYLOAD *sequenceParamPayload);
 
 
 /// \endcond
@@ -3867,7 +3867,7 @@ typedef struct _NV_ENCODE_API_FUNCTION_LIST
     PNVENCREGISTERRESOURCE          nvEncRegisterResource;             /**< [out]: Client should access ::NvEncRegisterResource() API through this pointer.         */
     PNVENCUNREGISTERRESOURCE        nvEncUnregisterResource;           /**< [out]: Client should access ::NvEncUnregisterResource() API through this pointer.       */
     PNVENCRECONFIGUREENCODER        nvEncReconfigureEncoder;           /**< [out]: Client should access ::NvEncReconfigureEncoder() API through this pointer.       */
-    void*                           reserved1;
+    void                           *reserved1;
     PNVENCCREATEMVBUFFER            nvEncCreateMVBuffer;               /**< [out]: Client should access ::NvEncCreateMVBuffer API through this pointer.             */
     PNVENCDESTROYMVBUFFER           nvEncDestroyMVBuffer;              /**< [out]: Client should access ::NvEncDestroyMVBuffer API through this pointer.            */
     PNVENCRUNMOTIONESTIMATIONONLY   nvEncRunMotionEstimationOnly;      /**< [out]: Client should access ::NvEncRunMotionEstimationOnly API through this pointer.    */
@@ -3875,7 +3875,7 @@ typedef struct _NV_ENCODE_API_FUNCTION_LIST
     PNVENCSETIOCUDASTREAMS          nvEncSetIOCudaStreams;             /**< [out]: Client should access ::nvEncSetIOCudaStreams API through this pointer.           */
     PNVENCGETENCODEPRESETCONFIGEX   nvEncGetEncodePresetConfigEx;      /**< [out]: Client should access ::NvEncGetEncodePresetConfigEx() API through this pointer.  */
     PNVENCGETSEQUENCEPARAMEX        nvEncGetSequenceParamEx;           /**< [out]: Client should access ::NvEncGetSequenceParamEx() API through this pointer.       */
-    void*                           reserved2[277];                    /**< [in]:  Reserved and must be set to NULL                                                 */
+    void                           *reserved2[277];                    /**< [in]:  Reserved and must be set to NULL                                                 */
 } NV_ENCODE_API_FUNCTION_LIST;
 
 /** Macro for constructing the version field of ::_NV_ENCODEAPI_FUNCTION_LIST. */
@@ -3885,7 +3885,7 @@ typedef struct _NV_ENCODE_API_FUNCTION_LIST
 /**
  * \ingroup ENCODE_FUNC
  * Entry Point to the NvEncodeAPI interface.
- * 
+ *
  * Creates an instance of the NvEncodeAPI interface, and populates the
  * pFunctionList with function pointers to the API routines implemented by the
  * NvEncodeAPI interface.
  